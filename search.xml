<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2022/05/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>图床测试</title>
    <url>/2022/05/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="如你所见"><a href="#如你所见" class="headerlink" title="如你所见"></a>如你所见</h2><p>我刚刚创建了一个免费图床,它叫做我的图床,虽然不知道是否稳定,但是感觉应该很快</p>
<p>试着加入一个贴图</p>
<p><img src="https://tu.my/i/2022/05/24/628c9fac53f6a.jpeg"></p>
<p>他好像上传成功了,你可以试着打开网页源代码,看看这副图片是不是来自其他网站的。</p>
<p>ps: 上面这个tags好麻烦,想想如何去掉它。</p>
]]></content>
  </entry>
  <entry>
    <title>我的第一个博客</title>
    <url>/2022/05/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="欢迎来到德莱联盟"><a href="#欢迎来到德莱联盟" class="headerlink" title="欢迎来到德莱联盟"></a>欢迎来到德莱联盟</h2>]]></content>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统大作业</title>
    <url>/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="一、计算题"><a href="#一、计算题" class="headerlink" title="一、计算题"></a>一、计算题</h1><p>本文转载自：<a href="https://blog.csdn.net/ChristensonLee/article/details/124169297?spm=1001.2014.3001.5502">KirinLee_01的博客-CSDN博客</a></p>
<blockquote>
<p>一个文件系统中有一个20MB大文件和一个20KB小文件,当分别采用连续、链接、i-node(10个直接地址，一个一级间接、一个二级间接和一个三级间接)分配方案时，每块大小为4KB,每块地址用4B表示，</p>
</blockquote>
<h2 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h2><blockquote>
<p>(1)各文件系统管理的最大的文件是多少?<br>(2)每种方案对大、小两文件各需要多少专用块来记录文件的物理地址(说明各块的用途)?<br>(3)如需要读大文件前面第5.5KB的信息和后面第（16M＋5.5KB）的信息，则每个方案各需要多少次盘I&#x2F;O操作?<br>(4)根据上述情况，分析比较三种文件分配方式的优劣。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d918bad25d.png" alt="在这里插入图片描述"></p>
<h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><h4 id="（1）各文件系统管理的最大的文件如下："><a href="#（1）各文件系统管理的最大的文件如下：" class="headerlink" title="（1）各文件系统管理的最大的文件如下："></a>（1）各文件系统管理的最大的文件如下：</h4><blockquote>
<p><strong>①连续分配：</strong></p>
<p>理论上是不受限制，可大到整个磁盘文件区。<br><strong>②链接分配：</strong></p>
<p>由于块的地址为4B，所以能表示的最多块数为2^32^&#x3D;4G，而每个盘块中存放文件大小为4KB。链接分配可管理的最大文件为：4G×4KB&#x3D;16368GB。</p>
<p><strong>③i-node分配</strong>：<br>由于盘块大小为4KB，每个地址用4B表示，一个盘块可存1K个索引表目。对于i-node(10个直接地址，一个一级间接、一个二级间接和一个三级间接)分配，即：10×4KB+ 4KB×1KB + 4KB×1KB×1KB + 4KB×1KB×1KB×1KB，因此可管理的最大文件为：4TB4GB4MB40KB。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d950936cd0.png" alt="在这里插入图片描述"></p>
<h4 id="（2）每种方案记录文件的物理地址所需的专用块数如下："><a href="#（2）每种方案记录文件的物理地址所需的专用块数如下：" class="headerlink" title="（2）每种方案记录文件的物理地址所需的专用块数如下："></a>（2）每种方案记录文件的物理地址所需的专用块数如下：</h4><blockquote>
<p><strong>①连续分配：</strong><br>对大小两个文件都只需在文件控制块FCB中设二项，一是首块物理块块号，另一是文件总块数，不需专用块来记录文件的物理地址。<br><strong>②链接分配：</strong><br>对大小两个文件都只需在文件控制块FCB中设二项，一是首块物理块块号，另一是末块物理块块号；同时在文件的每个物理块中设置存放下一个块号的指针,故不需专用块来记录文件的物理地址。<br><strong>③i-node分配：</strong><br>对20KB小文件只需在文件控制块FCB的i_addr[15]中使用前5个表目存放文件的物理块号，不需专用物理块。<br>对20MB大文件，FCB的i_addr[15]中使用前10个表目存放大文件前10块物理块块号（40K），用一级索引块1块保存大文件接着的1K块块号（4M），剩下还有不到16M，还要用二级索引存大文件以后的块号，二级索引使用第一级索引1块，第二级索引4块（因为4KB×1K×4&#x3D;16M）。<br>总共也需要6块专用物理块来存放文件物理地址。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d95164cfba.png" alt="在这里插入图片描述"></p>
<h4 id="（3）每个方案所需的盘I-x2F-O操作次数如下："><a href="#（3）每个方案所需的盘I-x2F-O操作次数如下：" class="headerlink" title="（3）每个方案所需的盘I&#x2F;O操作次数如下："></a>（3）每个方案所需的盘I&#x2F;O操作次数如下：</h4><blockquote>
<p><strong>①连续分配：</strong><br>为读大文件前面和后面信息都需先计算信息在文件中相对块数，前面信息相对逻辑块号为5.5K&#x2F;4K&#x3D;1（从0开始编号），再读一次得到所需信息，共2次盘I&#x2F;O。后面信息相对逻辑块号为（16M＋5.5K）&#x2F;4K&#x3D;4097。再计算物理块号＝文件首块号＋相对逻辑块号，最后一次盘I&#x2F;O操作读出该块信息，共4098次盘I&#x2F;O。<br><strong>②链接分配：</strong><br>为读大文件前面5.5KB的信息，只需先读一次文件头块得到信息所在块的块号，再读一次第1号逻辑块得到所需信息，共2次。<br>读大文件16MB＋5.5KB处的信息，逻辑块号为（16M＋5.5K）&#x2F;4092&#x3D;4107，要先把该信息所在块前面块顺序读出，共化4107次盘I&#x2F;O操作，才能得到信息所在块的块号，最后一次I&#x2F;O操作读出该块信息。所以总共需要4108次盘I&#x2F;O才能读取（16MB+5.5KB）处信息。<br><strong>③i-node分配：</strong><br>为读大文件前面5.5KB处信息，先根据它的相对逻辑块号，在内存文件控制块FCB的i_addr第二个表目中读取信息所在块块号，而1次盘I&#x2F;O操作即可读出该块信息。<br>为读大文件后在（16MB＋5.5KB）信息，先根据它的相对逻辑块号判断要读的信息是在二级索引管理范围内，先根据i_addr内容进行一次盘I&#x2F;O操作读出第一级索引块，再计算信息所在块的索引块号在第一级索引块的表目号为（4097-10-1024）&#x2F;1024＝2，根据第一级索引块第3个表目内容再进行一次盘I&#x2F;O操作，读出第二级索引块，就可以得到信息所在块块号，最后一次盘I&#x2F;O读出信息所在盘块，这样总共需要3次盘I&#x2F;O操作才能读出文件后面的信息。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d952a54332.png" alt="在这里插入图片描述"></p>
<h4 id="（4）由上可知三种文件分配方式的优劣如下："><a href="#（4）由上可知三种文件分配方式的优劣如下：" class="headerlink" title="（4）由上可知三种文件分配方式的优劣如下："></a>（4）由上可知三种文件分配方式的优劣如下：</h4><blockquote>
<p><strong>①连续分配：</strong><br>该方式要求每个文件在磁盘上占有一组连续的块。因此，物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片。可以用紧凑来处理磁盘碎片，但是会需要耗费很大的时间代价。<br><strong>优点</strong>：实现简单，顺序存取速度快，适合顺序访问和直接访问（随机访问）。<br><strong>缺点：</strong>分配速度慢，不方便文件拓展，存储空间利用率低，外存碎片多（类似内存的可重定位可变分区分配）。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d954207ba2.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>②链接分配：</strong><br>该方式解决了连续分配的所有问题。采用链接分配，每个文件是磁盘块的链表；磁盘块可能会散布在磁盘的任何地方。目录包括文件第一块和最后一块的指针。<br><strong>优点：</strong>采用链接分配没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>它只能有效用于顺序访问文件。要找到文件的第i个块，必须从文件的开始起，跟着指针，找到第i块。每个指针的访问都需要一个磁盘读，有时需要磁盘寻道。因此，链接分配不能有效支持文件的直接访问。另一个缺点是指针所需的空间。如果指针需要使用512 字节块的 4 字节，则 0.78% 的磁盘空间会用于指针，而不是其他信息。<br>因此，每个文件需要比原来稍多的空间，可靠性也降低，因为文件是通过散布在磁盘上的指针链接起来的，操作系统软件错误或磁盘硬件故障可能导致获得一个错误指针，这个错误可能会导致链接到空闲空间列表或链接到另一个文件。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d954c840f1.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><strong>③i-node分配：</strong><br>链接分配解决了连续分配的外部碎片和大小声明的问题。然而，在没有 FAT时，链接分配不能支持髙效的直接访问，因为块指针与块一起分散在整个磁盘上，并且必须按序读取。那么索引分配（i-node）通过将所有指针放在一起，即索引块，解决了这个问题。每个文件都有自己的索引块，这是一个磁盘块地址的数组。索引块的第 i 个条目指向文件的第 i 个块。目录包含索引块的地址。当查找和读取第 i 个块时，采用第 i 个索引块条目的指针。<br><strong>优点：</strong>索引分配支持直接访问，并且没有外部碎片问题，因为磁盘的任何空闲块可以满足更多空间的请求。<br><strong>缺点：</strong>索引分配确实浪费空间。索引块指针的开销通常大于链接分配的指针开销。采用索引分配，即使只有一个或两个指针是非空的，也必须分配一个完整的索引块。然而，索引分配的性能取决于索引结构、文件大小以及所需块的位置，这显得比前两种方式不确定性高许多。</p>
</blockquote>
<p><img src="https://tu.my/i/2022/05/25/628d955cddb0f.png" alt="在这里插入图片描述"></p>
<p><img src="https://tu.my/i/2022/05/25/628d956a22e2a.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>本文用于练习markdown语法,如有侵权,请联系删除。</p>
</blockquote>
]]></content>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>软件工程题库</title>
    <url>/2022/05/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%A2%98%E5%BA%93/</url>
    <content><![CDATA[<h1 id="软件工程期末题库整理-仅供参考"><a href="#软件工程期末题库整理-仅供参考" class="headerlink" title="软件工程期末题库整理(仅供参考)"></a>软件工程期末题库整理(仅供参考)</h1><blockquote>
<p>欢迎来寻找bug,在评论区留言~</p>
</blockquote>
<h2 id="一、判断题"><a href="#一、判断题" class="headerlink" title="一、判断题"></a>一、判断题</h2><blockquote>
<p>特别感谢徐行大佬、杨群大佬找出错误。</p>
</blockquote>
<ol>
<li><p>软件就是程序，编写软件就是编写程序。 （X ）</p>
</li>
<li><p>软件危机的主要表现是软件需求增加，软件价格上升。 （ X ）</p>
</li>
<li><p>软件工程学科出现的主要原因是软件危机的出现。 （ √ ）</p>
</li>
<li><p>瀑布模型的最大优点是将软件开发的各个阶段划分得十分清晰。 ( X )</p>
<span id="more"></span>
</li>
<li><p>原型化开发方法包括生成原型和实现原型两个步骤。 (X )</p>
</li>
<li><p>软件过程改进也是软件工程的范畴。 ( √ )</p>
</li>
<li><p>在软件开发中采用原型系统策略的主要困难是成本问题。 ( X )</p>
</li>
<li><p>需求规格说明书在软件开发中具有重要的作用，它也可以作为软件可行性分析的依据。( X )</p>
</li>
<li><p>需求分析的主要目的是解决软件开发的具体方案。 ( X )</p>
</li>
<li><p>需求规格说明书描述了系统每个功能的实现。 ( X )</p>
</li>
<li><p>非功能需求是从各个角度对系统的约束和限制,反映了应用对软件系统质量和特性的额外要求。 ( √ )</p>
</li>
<li><p>需求评审人员主要由开发人员组成，一般不包括用户。 ( X )</p>
</li>
<li><p>分层的DFD图可以用于可行性分析阶段，描述系统的物理结构。 ( X )</p>
</li>
<li><p>信息建模方法是从数据的角度来建立信息模型的，最常用的描述信息模型的方法是E-R图。 ( √ )</p>
</li>
<li><p>用于需求分析的软件工具，应该能够保证需求的正确性，即验证需求的一致性、 完整性、现实性和有效性。 ( √ )</p>
</li>
<li><p>需求分析是开发方的工作，用户的参与度不大。 ( X )</p>
</li>
<li><p>软件设计说明书是软件概要设计的主要成果。 ( X )</p>
</li>
<li><p>软件设计中设计复审和设计本身一样重要，其主要作用是避免后期付出高昂代价。( √ )</p>
</li>
<li><p>划分模块可以降低软件的复杂度和工作量，所以应该将模块分得越小越好。 ( X )</p>
</li>
<li><p>SD法是一种面向数据结构的设计方法，强调程序结构与问题结构相对应。 ( X )</p>
</li>
<li><p>判定表的优点是容易转换为计算机实现，缺点是不能够描述组合条件。 ( X )</p>
</li>
<li><p>模块独立要求高耦合低内聚。 ( X )</p>
</li>
<li><p>程序设计语言是指编程时表现出来的特点、习惯、逻辑思维等。 ( X )</p>
</li>
<li><p>进行程序设计语言的选择时，首先考虑的是应用领域。 ( √ )</p>
</li>
<li><p>好程序的一个重要标准是源程序代码的逻辑简明清晰、易读易懂。 ( √ )</p>
</li>
<li><p>软件测试的目的是尽可能多地发现软件中存在的错误，将它作为纠错的依据。( √ )</p>
</li>
<li><p>测试用例由输人数据和预期的输出结果两部分组成。 ( √ )</p>
</li>
<li><p>白盒测试是结构测试，主要以程序的内部逻辑为基础设计测试用例。 ( √ )</p>
</li>
<li><p>软件测试的目的是证明软件是正确的。 ( X )</p>
</li>
<li><p>单元测试通常应该先进行”人工走查”，再以白盒法为主，辅以黑盒法进行动态测试。( √ )</p>
</li>
<li><p>白盒法是一种静态测试方法，主要用于模块测试。 ( X )</p>
</li>
<li><p>在等价分类法中，为了提高测试效率，一个测试用例可以覆盖多个无效等价类。( X )</p>
</li>
<li><p>发现错误多的模块，残留在模块中的错误也多。 ( √ )</p>
</li>
<li><p>类是指具有相同或相似性质的对象的抽象，类的具体化就是对象。 （ √ ）</p>
</li>
<li><p>继承性是父类和子类之间共享数据结构和消息的机制，这是类之间的一种关系。（ X ）</p>
</li>
<li><p>多态性增强了软件的灵活性和重用性，允许用更为明确、易懂的方式去建立通用软件， 多态性和继承性相结合使软件具有更广泛的重用性和可护充性。 （ √ ）</p>
</li>
<li><p>类的设计过程包括:确定类，确定关联类，确定属性，识别继承关系。 （ √ ）</p>
</li>
<li><p>用面向对象方法开发的软件系统，可维护性好。 （ √ ）</p>
</li>
<li><p>模型是对现实的简化，建模是为了更好地理解所开发的系统。 （ √ ）</p>
</li>
<li><p>多态性防止了程序相互依赖而带来的变动影响。 （ X ）</p>
</li>
<li><p>类封装比对象封装更具体、更细致。 （ X ）</p>
</li>
<li><p>面向对象的继承性是子类自动共享父类数据结构和方法的机制。 （ √ ）</p>
</li>
<li><p>面向对象的开发方法将过程作为最基本的元素，是分析问题、解决问题的核心。( X )</p>
</li>
<li><p>用例需求分析方法采用的是一种结构化的情景分析方法，即是一种基于场景建模的方法 ( X )</p>
</li>
<li><p>面向对象分析方法认为系统是对象的集合，是以功能和数据为基础的。 ( √ )</p>
</li>
<li><p>面向对象分析的核心在于建立一个描述软件系统的模型 。 ( X )</p>
</li>
<li><p>面向对象的分析过程主要包括三项内容:理解、表达和验证。 ( √ )</p>
</li>
<li><p>面向对象分析就是抽取和整理用户需求并建立问题域精确模型的过程。 ( √ )</p>
</li>
<li><p>面向对象的方法是以类作为最基本的元素，它是分析问题、解决问题的核心。( X )</p>
</li>
<li><p>功能模型是类似编译器之类系统的主要模型。 ( √ )</p>
</li>
<li><p>软件设计一般分为总体设计和详细设计，它们之间的关系是全局和局部。 ( √ )</p>
</li>
<li><p>在面向对象的设计中，应遵循的设计准则除了模块化、抽象、低耦合、高内聚以外，还有信息隐藏。 ( √ )</p>
</li>
<li><p>一个设计得好的软件系统具有低内聚、高耦合的特征。 ( X )</p>
</li>
<li><p>面向对象分析和设计活动是一个多次反复迭代的过程。 ( √ )</p>
</li>
<li><p>关系数据库可以完全支持面向对象的概念，面向对象设计中的类可以直接对应到关系数据库中的表。 (X)</p>
</li>
<li><p>用户界面设计对于一个系统的成功是至关重要的，一个设计得很差的用户界面可能导致用户拒绝使用该系统。 ( √ )</p>
</li>
<li><p>一般来说，应该尽量选用面向对象语言来实现面向对象分析、设计的结果。 ( √ )</p>
</li>
<li><p>良好的面向对象程序设计风格，既包括传统的程序设计风格准则，也包括为适应面向对象方法所特有的概念( 如继承性)而必须遵循的一些新准则。 ( √ )</p>
</li>
<li><p>面向对象测试用例的设计由软件的输入--处理--输出视图或单个模块的算法细节驱动。 ( X )</p>
</li>
<li><p>面向对象系统的确认测试是面向白盒的，并且可以应用传统的白盒方法完成测试工作。 ( X )</p>
</li>
<li><p>UML是一种建模语言，是一种标准的表示，是一种方法。 ( X )</p>
</li>
<li><p>泳道是一种分组机制，它描述了状态图中对象所执行的活动。 ( √ )</p>
</li>
<li><p>类图中的角色是用于描述该类在关联中所扮演的角色和职责的。 ( √ )</p>
</li>
<li><p>类图用来表示系统中类与类之间的关系,它是对系统动态结构的描述。 ( X )</p>
</li>
<li><p>用例模型的基本组成部件是用例、角色和用例之间的联系。 ( √ )</p>
</li>
<li><p><strong>用例之间有扩展、使用、组合等几种关系。 ( X )</strong></p>
</li>
<li><p>顺序图描述对象之间的交互关系，重点描述对象间消息传递的时间顺序。 ( √ )</p>
</li>
<li><p>活动图显示动作及其结果，着重描述操作实现中所完成的工作，以及用例实例或类中的活动。 ( X )</p>
</li>
<li><p>UML 语言支持面向对象的主要概念，并与具体的开发过程相关。 ( X )</p>
</li>
<li><p>部署图描述系统硬件的物理拓扑结构以及在此结构上执行的软件。 ( √ )</p>
</li>
<li><p>代码行技术是比较简单的定量估算软件规模的方法。 ( √ )</p>
</li>
<li><p>功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。( √ )</p>
</li>
<li><p>民主制程序员组的一-个重要特点是，小组成员完全平等，享有充分民主，通过协商做出技术决策。 ( √ )</p>
</li>
<li><p>主程序员组的两个关键特性是专业化和层次性。 ( √ )</p>
</li>
<li><p>现代程序员组中，技术组长既对技术工作负责，又负责非技术事务。 ( X )</p>
</li>
<li><p>总体上说，软件工程文档可以分为用户文档、开发文档和管理文档三类。 ( √ )</p>
</li>
<li><p>文档是影响软件可维护性的决定因素。 ( √ )</p>
</li>
<li><p>适应性维护是在软件使用过程中，用户会对软件提出新的功能和性能要求，为了满足这些新的要求而对软件进行修改，使之在功能和性能上得到完善和增强的活动。 ( X )</p>
</li>
<li><p>进行软件维护活动时，直接修改程序，无需修改文档。 ( X )</p>
</li>
<li><p>软件生命周期的最后一个阶段是书写软件文档。 ( X )</p>
</li>
</ol>
<h2 id="二、选择题"><a href="#二、选择题" class="headerlink" title="二、选择题"></a>二、选择题</h2><p>1.在下列选项中，（ D ）不是软件的特征。</p>
<p>A.系统性与复制性 B.可靠性与一致性</p>
<p>C.抽象性与智能性 D.有形性与可控性</p>
<p>2.软件危机的主要原因是（ D ）。</p>
<p>A.软件工具落后 B.软件生产能力不足</p>
<p>C.对软件的认识不够 D.软件本身的特点及开发方法</p>
<p>3.下列说法中正确的是（ B ）。</p>
<p>A.20世纪50年代提出了软件工程的概念</p>
<p>B.20世纪60年代提出了软件工程的概念</p>
<p>C.20 世纪70年代出现了客户机&#x2F;服务器技术</p>
<p>D.20世纪80年代软件工程学科达到成熟</p>
<p>4.( C )是将系统化的、规范的、可定量的方法应用于软件的开发、运行和维护的过程，它包括方法、工具和过程三个要素。</p>
<p>A.软件生命周期 B. 软件测试 C.软件工程 D.软件过程</p>
<p>5.在下列选项中, (A )不属于软件工程学科所要研究的基本内容。</p>
<p>A.软件工程材料 B.软件工程目标 C.软件工程原理 D. 软件工程过程</p>
<p>6.软件工程的三要素是( C)。</p>
<p>A.技术、方法和工具 B. 方法、对象和类</p>
<p>C.方法、工具和过程 D.过程、模型和方法</p>
<p>7.用来辅助软件开发、运行、维护、管理、支持等过程中的活动的软件称为软件开发工具，通常也称为( D) 工具。</p>
<p>A. CAD B. CAI C. CAM D. CASE</p>
<p>8.软件生命周期模型不包括( B )。</p>
<p>A.瀑布模型 B.用例模型 C.增量模型 D.螺旋模型</p>
<p>9.包含风险分析的软件工程模型是( D )。</p>
<p>A.喷泉模型 B.瀑布模型 C.增量模型 D.螺旋模型</p>
<p>10.软件过程是( C )。</p>
<p>A.特定的开发模型 B.一种软件求解的计算逻辑</p>
<p>C.软件开发活动的集合 D.软件生命周期模型</p>
<p>11.软件工程中描述生命周期的瀑布模型一般包括计划、需求分析、设计、编码、( D )、维护等几个阶段。</p>
<p>A.产品发布 B.版本更新 C.可行性分析 D.测试</p>
<p><strong>12.软件开发的瀑布模型，一般都将开发过程划分为:分析、设计、编码和测试等阶段，一般认为可能占用人员最多的阶段是(C )。</strong></p>
<p><strong>A.分析阶段 B.设计阶段 C.编码阶段 D.测试阶段</strong></p>
<p>13.增量模型本质上是一种(C )。</p>
<p>A.线性顺序模型 B.整体开发模型 C.非整体开发模型 D.螺旋模型</p>
<p>14.螺旋模型综合了(B ) 的优点，并增加了风险分析。</p>
<p>A.增量模型和喷泉模型 B.瀑布模型和演化模型</p>
<p>C.演化模型和喷泉模型 D.原型和喷泉模型</p>
<p>15. CMM模型将软件过程的成熟度分为5个等级。在( B) 使用定量分析来不断地改进和管理软件过程。</p>
<p>A.管理级 B.优化级 C.定义级 D.可重复级</p>
<p>16.需求工程的主要目的是(C )。</p>
<p>A.系统开发的具体方案 B.进一步确定用户的需求</p>
<p>C.解决系统是”做什么的问题” D.解决系统是”如何做的问题&quot;</p>
<p>17.需求分析的主要方法有( C)。</p>
<p>A.形式化分析方法 B.PAD 图描述</p>
<p>C.结构化分析SA方法 D.程序流程图</p>
<p>18.SA法的主要描述手段有(B )。</p>
<p>A.系统流程图和模块图 B.DFD图、数据词典、加工说明</p>
<p>C.软件结构图、加工说明 D.功能结构图、加工说明</p>
<p>19.画分层DFD图的基本原则有( C)。</p>
<p>A.数据守恒原则 B.分解的可靠性原则</p>
<p>C.子、父图平衡的原则 D.数据流封闭的原则</p>
<p>20.在E-R模型中，包含以下基本成分(D )。</p>
<p>A.数据、对象、实体 B.控制、关系、对象</p>
<p>C.实体、关系、控制 D.实体、属性、关系.</p>
<p>21.在下面的叙述中哪一个不是软件需求分析的任务? ( C )。</p>
<p>A.问题分解 B.可靠性与安全性要求</p>
<p>C.结构化程序设计 D.确定逻辑模型</p>
<p>22.需求规格说明书的作用不应包括(D )。</p>
<p>A.软件设计的依据 B.用户与开发人员对软件要做什么的共同理解</p>
<p>C.软件验收的依据 D.软件可行性研究的依据</p>
<p>23.软件需求规格说明书的内容不应该包括( B)。</p>
<p>A.对重要功能的描述 B.对算法的详细过程描述</p>
<p>C.对数据的要求 D.软件的性能</p>
<p>24.软件需求分析阶段的工作，可以分为以下4个方面:对问题的识别、分析与综合、编写需求分析文档以及(C )。</p>
<p>A.总结 B.阶段性报告</p>
<p>C.需求分析评审 D.以上答案都不正确</p>
<p>25.下述任务中， 不属于软件工程需求分析阶段的是(D )。</p>
<p>A.分析软件系统的数据要求 B.确定软件系统的功能需求</p>
<p>C.确定软件系统的性能要求 D.确定软件系统的运行平台</p>
<p>26.进行需求分析可使用多种工具,但(B )是不适用的。</p>
<p>A.数据流图 B. PAD图 C.状态转换图 D. 数据词典</p>
<p>27.在需求分析之前有必要进行(B ) 工作。</p>
<p>A.程序设计 B.可行性分析 C.ER分析 D.2NF分析</p>
<p>28.数据流图是进行软件需求分析的常用图形工具，其基本图形符号是(C )。</p>
<p>A.输人、输出、外部实体和加工 B. 变换、加工、数据流和存储</p>
<p>C.加工、数据流、数据存储和外部实体 D. 变换、数据存储、加工和数据流</p>
<p>29.在结构化分析方法中，用以表达系统内数据的运动情况的工具是( A )。</p>
<p>A.数据流图 B.数据字典 C.结构化语言 D.判定表与判定树</p>
<p>30.为了提高模块的独立性，模块之间最好是(C )。</p>
<p>A.公共环境耦合 B.控制耦合 C.数据耦合 D.特征耦合</p>
<p>31.在面向数据流的软件设计方法中，一般将信息流分为( D)。</p>
<p>A.数据流和控制流 B.变换流和控制流 C.事务流和控制流 D.变换流和事务流</p>
<p>32.模块独立性是软件模块化所提出的要求，衡量模块独立性的度量标准是模块的(A )。</p>
<p>A.内聚性和耦合性 B.局部化和封装化 C.抽象和信息隐藏 D.逐步求精和结构图</p>
<p>33.模块的独立性是由内聚性和耦合性来度量的，其中内聚性是( C )。</p>
<p>A.模块间的联系程度 B.信息隐藏程度 C.模块的功能强度 D.接口的复杂程度</p>
<p>34.当算法中需要用一个模块去计算多种条件的复杂组合.并根据这些条件完成适当的功能时，从供选择的答案中，选出合适的描述工具。( D)</p>
<p>A.程序流程图 B.N-S 图 C.PAD图 D.判定表</p>
<p>35.面向数据流的软件设计方法可将( C)映射成软件结构。</p>
<p>A.控制结构 B.模块 C.数据流 D.事物流</p>
<p>36.Jackson 方法根据( C )来导出程序结构。</p>
<p>A.数据流图 B.数据间的控制结构 C.数据结构 D. IPO图</p>
<p>37.程序语言的特性包括(B)。</p>
<p>A.习惯特性 B.算法特性 C.工程特性 D.技术特性</p>
<p>38.软件实现是软件产品由概念到实体的一个 关键过程,它将(A )的结果翻译成用某种程序设计语言编写的并且最终可以运行的程序代码。虽然软件的质量取决于软件设计，但是规范的程序设计风格将会对后期的软件维护带来不可忽视的影响。</p>
<p>A.软件设计 B.详细设计 C.架构设计 D.总体设计</p>
<p>39.成功的测试是指运行测试用例后（ A ）</p>
<p>A.发现了程序错误 B.未发现程序错误 C.证明程序正确 D.改正了程序错误</p>
<p>40.白盒测试法是根据程序的( B) 来设计测试用例的方法。</p>
<p>A.输出数据 B.内部逻辑 C.功能 D.输人数据</p>
<p>41.软件的集成测试工作最好由(C )承担，以提高集成测试的效果。</p>
<p>A.该软件的设计人员 B.该软件开发组的负责人</p>
<p>C.不属于该软件开发组的软件设计人员 D.该软件的编程人员</p>
<p>42.黑盒测试是从(C )观点的测试，白盒测试是从( )观点的测试。</p>
<p>A.开发人员、管理人员 B.用户、管理人员</p>
<p>C.用户、开发人员 D.开发人员、用户</p>
<p>43.软件测试可能发现软件中的( D ), 但不能证明软件( )。</p>
<p>A.所有错误、没有错误 B.设计错误、没有错误</p>
<p>C.逻辑错误、没有错误 D.错误、没有错误</p>
<p>44.软件测试的目的是(D )。</p>
<p>A.证明软件的正确性 B.找出软件系统中存在的所有错误</p>
<p>C.证明软件系统中存在错误 D.尽可能多的发现软件系统中的错误</p>
<p>45.使用白盒测试方法时确定测试数据应根据( A)和指定的覆盖标准。</p>
<p>A.程序的内部逻辑 B.程序的复杂程度</p>
<p>C.程序的难易程度 D.程序的功能</p>
<p>46.黑盒测试方法根据(B )设计测试用例。</p>
<p>A.程序的调用规则 B.软件要完成的功能</p>
<p>C.模块间的逻辑关系 D.程序的数据结构</p>
<p>47.在软件测试中，逻辑覆盖标准主要用于(A )。</p>
<p>A.白盒测试方法 B.黑盒测试方法</p>
<p>C.灰盒测试方法 D.回归测试方法</p>
<p>48.集成测试的主要方法有两个，一个是(C )一个是( )。</p>
<p>A.白盒测试方法、黑盒测试方法 B.等价类划分方法、边缘值分析方法</p>
<p>C.渐增式测试方法、非渐增式测试方法 D.因果图方法、错误推测方法.</p>
<p>49.验收测试的任 务是验证软件的(D )。</p>
<p>A.可靠性 B.正确性 C.移植性 D.有效性</p>
<p>50.软件测试的目的是尽可能发现软件中的错误，通常(D ) 是代码编写阶段可进行的测试，它是整个测试工作的基础。</p>
<p>A.集成测试 B.系统测试 C.验收测试 D. 单元测试</p>
<p>51.汽车有一个发动机，汽车和发动机之间的关系是( B ) 关系。</p>
<p>A.组装 B.整体部分 C.分类 D. 一般具体</p>
<p>52.(D ) 是把对象的属性和操作结合在一一起， 构成-个独立的对象，其内部信息对外界是隐藏的，外界只能通过有限的接口与对象发生联系。</p>
<p>A.多态性 B.继承 C.消息 D.封装</p>
<p>53. ( B) 意味着一个操作在不同的类中可以有不同的实现方式。</p>
<p>A.多继承 B.多态性 C.消息 D.封装</p>
<p>54.每个对象可用它自己的一组属性和它可以执行的一组(A )来表征。</p>
<p>A.操作 B.功能 C.行为 D.数据</p>
<p>55.应用执行对象的操作可以改变该对象的( C)。</p>
<p>A.行为 B.功能 C.属性 D.数据</p>
<p>56.面向对象的主要特征除了对象唯一性、封装性、继承性外,还有( D)。</p>
<p>A.兼容性 B.完整性 C.可移植性 D.多态性</p>
<p>57.关联是建立( B )之间关系的一种手段。</p>
<p>A.对象 B.类 C.功能 D.属性</p>
<p>58.面向对象软件技术的许多强有力的功能和突出的优点，都来源于把类组织成一个层次结构的系统，一个类的上层可以有父亲，下层可以有子类，这种层次结构系统的一个重要性质是 ( B ),一个类可获得其父亲的全部描述(数据和操作)。</p>
<p>A.兼容性 B.继承性 C.复用性 D.多态性</p>
<p>59.所有的对象可以成为各种对象类， 每个对象类都定义了一组(D )。</p>
<p>A.说明 B.类型 C.过程 D.方法</p>
<p>60.通过执行对象的操作改变对象的属性，但它必须通过( B )的传递。</p>
<p>A.操作 B.消息 C.信息 D.继承</p>
<p>61. 下列不属于面向对象的要素有( C)。</p>
<p>A.继承 B.抽象 C.分类性 D.封装</p>
<p>62.面向对象分析的首要工作是建立(D )。</p>
<p>A.系统的动态模型 B.系统的功能模型</p>
<p>C.基本的E-R模型 D.问题的对象模型</p>
<p>63.面向对象的分析方法主要是建立三类模型，即( B).</p>
<p>A.系统模型、ER模型、应用模型 B.对象模型、动态模型、功能模型</p>
<p>C.ER模型、对象模型、功能模型 D.对象模型、动态模型、应用模型</p>
<p>64.软件开发过程中，抽取和整理用户需求并建立问题域精确模型的过程叫( C )。</p>
<p>A.生命周期 B.面向对象设计 C.面向对象分析 D.面向对象程序设计</p>
<p>65.面向对象分析阶段建立的3个模型中，核心的模型是( C) 模型。</p>
<p>A.功能 B.动态 C.对象 D.分析</p>
<p>66.面向对象分析是对系统进行(C)的一一种方法。</p>
<p>A.设计评审 B.程序设计 C.需求建模 D.测试验收</p>
<p>67.应该在( B )，确定对象类中应有的服务。</p>
<p>A.建立对象模型之时 B.建立动态模型和功能模型之后</p>
<p>C.建立功能模型之后 D.建立动态模型之后</p>
<p><strong>68.面向对象的动态模型中，每张状态图表示(A ) 的动态行为。</strong></p>
<p><strong>A.某一个类 B.有关联的若干个类 C.一系列事件 D.一系列状态</strong></p>
<p>69.在考察系统的-些涉及时序和改变的状况时，要用动态模型来表示。动态模型着重于系统的控制逻辑，它包括两个图:一个是事件追踪图，另一个是( B)。</p>
<p>A.顺序图 B.状态图 C.系统结构图 D.数据流图</p>
<p>70.动态模型的描述工具是( C)。</p>
<p>A.设计图 B.结构图 C.状态图 D.对象图</p>
<p>71.对象模型的描述工具是( D )。</p>
<p>A.状态图 B.数据流图 C.结构图 D.对象图</p>
<p>72.功能模型中所有的( D)往往形成一个层次结构，在这个层次结构中一个数据流图的过程可以由下一层数据流图做进一步的说明。</p>
<p>A.事件追踪图 B.物理模型图 C.状态迁移图 D.数据流图</p>
<p>73.只有类的共有界面的成员才能成为使用类的操作，这是软件设计的(B)原则。</p>
<p>A.过程抽象 B.信息隐藏 C.功能抽象 D.共享性</p>
<p>74.(B) 是表达系统类及其相互联系的图示，它是面向对象设计的核心，是建立状态图、</p>
<p>协作图和其他图的基础。</p>
<p>A.部署图 B.类图 C.组件图 D.配置图</p>
<p>75.下面所列的性质中，(D)不属于面向对象程序设计的特性。</p>
<p>A.继承性 B.重用性 C.封装性 D.可视化</p>
<p>76.下列是面向 对象设计方法中有关对象的叙述，其中(B ) 是正确的。</p>
<p>A.对象在内存中没有它的存储区 B.对象的属性集合是它的特征表示</p>
<p>C.对象的定义与程序中类型概念相当 D.对象之间不能相互通信</p>
<p>77.面向对象程序设计中，基于父类创建的子类具有父类的所有特性(属性和方法),这一特点称为类的( C)。</p>
<p>A.多态性 B.封装性 C.继承性 D.重用性</p>
<p>78.面向对象设计00D模型的主要部件中，通常不包括(A)</p>
<p>A.通信部件 B.人机交互部件 C.任务管理 D.数据管理</p>
<p>79.面向对象设计时，对象信息的隐藏主要是通过(A ) 实现的。</p>
<p>A.对象的封装性 B.子类的继承性 C.系统模块化 D.模块的可重用</p>
<p>80.面向对象设计阶段的主要任务是系统设计和(D )。</p>
<p>A.结构化设计 B.数据设计 C.面向对象程序设计 D.对象设计</p>
<p>81.面向对象的实现主要包括( A)。</p>
<p>A.把面向对象设计用某种程序设计语言书写为面向对象程序,测试并调试面向对象的程序</p>
<p>B.面向对象设计</p>
<p>C.选择面向对象语言</p>
<p>D.单元测试</p>
<p>82.面向对象程序设计语言不同于其他语言的最主要特点是( C)。</p>
<p>A.模块性 B.抽象性 C.继承性 D.内聚性</p>
<p><strong>83.面向对象的测试与传统测试方法的主要区别是(A )。</strong></p>
<p>A.面向对象的测试可在编码前进行，传统测试方法在编码后进行</p>
<p>B.面向对象的测试以需求和设计阶段的测试为主，不需要进行代码测试</p>
<p>C.测试对象不同</p>
<p>D.面向对象的测试不需要设计测试用例，只需要进行会议评审</p>
<p>84.UML是软件开发中的一个重要T具，它主要应用于(D )。</p>
<p>A.基于螺旋模型的结构化方法 B. 基于需求动态定义的原型化方法</p>
<p>C.基于数据的数据流开发方法 D.基于对象的面向对象的方法</p>
<p>85.( C) 是从用户使用系统的角度描述系统功能的图形表达方法。</p>
<p>A.类图 B.活动图 C.用例图 D.状态图</p>
<p>86.( A) 是表达系统类及其相互联系的图示，它是面向对象设计的核心，是建立状态图、</p>
<p>协作图和其他图的基础。</p>
<p>A.类图 B.状态图 C.对象图 D.部署图</p>
<p>87.(B ) 描述了一组交互对象间的动态协作关系，它表示完成某项行为的对象和这些对象之间传递消息的时间顺序。</p>
<p>A.类图 B.顺序图 C.状态图 D.协作图</p>
<p>88.(C)是用于表示构成分布式系统的节点集和节点之间的联系的图示，它可以表示系统</p>
<p>中软件和硬件的物理架构。</p>
<p>A.组件图 B.类图 C.部署图 D.状态图</p>
<p>89.(A)定义了系统的功能需求，它是从系统的外部看系统功能，并不描述系统内部对功</p>
<p>能的具体实现。</p>
<p>A.用例图 B.类图 C.活动图 D.对象图</p>
<p>90.状态图包括( D )。</p>
<p>A.类的状态和状态之间的转换 B.触发类动作的事件</p>
<p>C.类执行的动作 D.所有以上选项</p>
<p>91. ( B) 的作用是为有效地、定量地进行管理，把握软件工程过程的实际情况和它所产生的产品质量,</p>
<p>A.估算 B.度量 C.风险分析 D.进度安排</p>
<p>92.LOC和FP是两种不同的估算技术，但两者有许多共同的特征，只是LOC和FP技术对于分解所需要的( A) 不同。</p>
<p>A.详细程度 B.分解要求 C.使用方法 D.改进过程</p>
<p>93.项目团队原来有6个成员，现在又增加了6个成员，这样沟通渠道增加了多少? ( A )</p>
<p>A.4.4倍 B.2倍 C. 6倍 D.6条</p>
<p>94. Mantei 提出了3种通用的项目组组织方式:民主分权式、控制分权式、( D )。</p>
<p>A.启发式 B.归纳式 C.总结式 D.控制集权式</p>
<p>95.下列哪项不是风险管理的过程?( D)</p>
<p>A.风险规划 B.风险识别 C.风险评估 D.风险收集</p>
<p>96.按照软件配置管理的原始指导思想，受控制的对象应是( C)。</p>
<p>A.软件过程 B.软件项目 C.软件配置项 D.软件元素</p>
<p>97.在软件维护的内容中，占维护活动工作量比例最高的是(D )。</p>
<p>A.纠错性维护 B.适应性维护 C.预防性维护 D.完善性维护</p>
<p>98.使用软件时提出增加新功能就必须进行(C ) 维护。</p>
<p>A.预防性 B.适应性 C.完善性 D.纠错性</p>
<p>99.软件文档是软件工程实施的重要成分，它不仅是软件开发各阶段的重要依据,而且也影响软件的( B)。</p>
<p>A.可用性 B.可维护性 C.可扩展性 D.可移植性</p>
<p>100影响软件可维护性的主要因素不包括( C)。</p>
<p>A.可修改性 B.可测试性 C.可用性 D.可理解性</p>
<blockquote>
<p>商业用途禁止转载，个人复习使用免费</p>
</blockquote>
]]></content>
      <tags>
        <tag>homework</tag>
      </tags>
  </entry>
</search>
