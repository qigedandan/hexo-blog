<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>锦的blog</title>
  
  <subtitle>保持自己的决心</subtitle>
  <link href="https://qgdd.vercel.app/atom.xml" rel="self"/>
  
  <link href="https://qgdd.vercel.app/"/>
  <updated>2022-06-15T13:20:08.557Z</updated>
  <id>https://qgdd.vercel.app/</id>
  
  <author>
    <name>七个旦旦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统复习提纲</title>
    <link href="https://qgdd.vercel.app/2022/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/"/>
    <id>https://qgdd.vercel.app/2022/06/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%8D%E4%B9%A0%E6%8F%90%E7%BA%B2/</id>
    <published>2022-06-15T13:18:57.000Z</published>
    <updated>2022-06-15T13:20:08.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="江苏大学-操作系统-知识点提纲-期末考试-x2F-考研-复习"><a href="#江苏大学-操作系统-知识点提纲-期末考试-x2F-考研-复习" class="headerlink" title="江苏大学 操作系统 知识点提纲 期末考试&#x2F;考研 复习"></a>江苏大学 操作系统 知识点提纲 期末考试&#x2F;考研 复习</h2><p>基于江苏大学教材《操作系统设计原理（第二版）》，科学出版社出版。詹永照、薛安荣主编。</p><p>部分内容与考试考点与王道考研等参考资料略有区别，请自行区分。</p><h3 id="选择题微信小程序刷题"><a href="#选择题微信小程序刷题" class="headerlink" title="选择题微信小程序刷题"></a>选择题微信小程序刷题</h3><p><a href="https://tu.my/i/2022/06/15/62a9dba0c9d8d.png">请点击这里</a></p><blockquote><p>注意：小程序用于学习通题目练习,与下面的知识提纲无关</p></blockquote><p>目录</p><p>第一章 绪论</p><span id="more"></span><p>第二章 进程与线程</p><p>第三章 互斥与同步</p><p>第四章 处理器调度</p><p>第五章 存储管理</p><p>第六章 文件管理</p><p>第七章 I&#x2F;O管理</p><p>第八章 操作系统安全性</p><p>第九章 新型操作系统</p><p>第十章 操作系统设计问题</p><h3 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h3><p><strong>1.操作系统定义：</strong></p><p>是计算机系统的一种系统软件，用于管理计算机的资源和控制程序的执行。</p><p><strong>2.提供用户的使用方式：</strong></p><p>命令行、系统调用、图标窗口。</p><p><strong>3.五大功能：</strong></p><p>处理机与进程管理、存储器管理、文件管理、设备管理、网络管理。</p><p><strong>4.分类：</strong></p><p>单用户操作系统（用户独占全机、CPU等待手工操作）、批处理操作系统（用户不能直接控制作业运行）、实时操作系统（事件驱动设计）、分时操作系统（同时、独立、交互、及时）、网络操作系统（提供网络服务）、分布式操作系统（资源共享、无主次、两两通信、程序并行运行）、嵌入式操作系统（管理系统资源、抽象硬件、提供开发工具库函数）。</p><p><strong>5.特权指令：</strong></p><p>只能由操作系统运行的指令是特权指令，用户不能运行。</p><p><strong>6.处理器状态：</strong></p><p>核心状态、管理状态、用户程序状态（管态和目态）</p><p><strong>7.程序状态字：</strong></p><p>指示处理机状态</p><p><strong>8.结构：</strong></p><p>电子线路、指令集、过程、中断、进程原语、局部辅存、虚拟存储器、通信（管道）、文件系统、设备、目录、用户进程、外壳。13层。</p><p><strong>9.现代操作系统特点：</strong></p><p>个人独占；多处理机；技术结构：微内核、多线程、对称多处理机、面向对象与软件工程原则。</p><h3 id="第二章-进程与线程"><a href="#第二章-进程与线程" class="headerlink" title="第二章 进程与线程"></a>第二章 进程与线程</h3><p><strong>1.并发执行特点：</strong></p><p>资源共享性、失去了封闭性和可再现性、相互制约性。</p><p><strong>2.进程定义：</strong></p><p>进程是能和其他程序并行执行的程序段在某数据集合上的一次运行过程，是系统资源分配和调度的一个独立单位。</p><p><strong>3.进程与程序：</strong></p><p>程序是指令集合，进程是程序一次运行活动；进程独立调度与其他进程并行，程序不能。一个程序可以对应多个进程。</p><p><strong>4.进程的组成：</strong></p><p>程序、数据集合、进程控制块PCB（与进程一一对应，是进程存在的标志）。</p><p><strong>5.进程的三态与转换：</strong></p><p>就绪、执行、阻塞。</p><p><strong>6.进程控制原语：</strong></p><p>创建、撤销、阻塞、唤醒。</p><p><strong>7.线程定义：</strong></p><p>线程是进程中的一个实体，是比进程更小的能独立运行的基本单位，不独立拥有资源。</p><p><strong>8.线程与进程：</strong></p><p>进程是资源的拥有者，有独立地址空间，不是处理器调度基本单位。线程不独立拥有资源，只有TCB和堆栈，共享地址空间，是处理器调度基本单位。</p><p><strong>9.多核、多线程与超线程：</strong></p><p>1.多核计算机打破单核环境下的正确性与可靠性。多核在一个CPU布置多个执行核（ALU）。</p><p>2.超线程在一个CPU上同时执行多个程序共同分享该CPU内资源，让应用程序在同一时间使用芯片不同部分。</p><p>3.多线程：任意时刻多个线程同时被调度运行。</p><h3 id="第三章-互斥与同步"><a href="#第三章-互斥与同步" class="headerlink" title="第三章 互斥与同步"></a>第三章 互斥与同步</h3><p><strong>1.并发进程产生的与时间有关的错误：</strong></p><p>结果不唯一、永远等待。</p><p><strong>2.临界区：</strong></p><p>在某段时间内只允许一个进程使用的资源是临界资源，并发进程访问临界资源的程序段是临界区。要求：互斥、进展、有限等待。</p><p><strong>3.信号量定义、物理意义：</strong></p><p>一个进程检测到某个信号后被强迫停止在一个特定的地方，直到收到一个专门的信号后才能继续执行。这个信号就称为”信号量”。信号量被定义为含有整型数据项的结构变量，其整型值大于0代表可供并发进程使用的资源实体数，小于0表示正在等待使用临界区的进程数。</p><p><strong>4.原语：</strong></p><p>执行时不可中断的过程。</p><p><strong>5.直接通信、间接通信：</strong></p><p>1.直接通信是指发送进程把信件直接发给接受进程。对称指名通信：Send(P,信件)，receive(Q,信件)。非对称指名通信方式：发送者先向系统申请缓冲区，把信件存入缓冲区。接受进程被唤醒，接收信件。</p><p>2.间接通信指把信件发送到共享的信箱中，接受进程到信箱取信件。</p><p><strong>6.死锁定义与四个必要条件：</strong></p><p>一组并发进程彼此相互等待对方占有的资源，在得到对方的资源之前不会释放自己占有的资源，造成这组进程都不能继续向前推进的情况。必要条件：互斥、部分分配、不可抢占、循环等待。</p><p><strong>7.死锁防止：</strong></p><p>1.资源静态分配（一个进程必须在执行前申请所需的全部资源，直到所需的资源得到满足后才开始执行）</p><p>2.资源层次分配（把资源分成多个层次，一个进程得到某一层资源后只能申请更高层资源，释放资源时先释放高层资源）。</p><p><strong>8.死锁避免：</strong></p><p>银行家算法。</p><p><strong>9.死锁检测与恢复：</strong></p><p>死锁检测：资源分配图与等待图。死锁解除（恢复）：撤销进程法、剥夺资源法。</p><h3 id="第四章-处理器调度"><a href="#第四章-处理器调度" class="headerlink" title="第四章 处理器调度"></a>第四章 处理器调度</h3><p><strong>1.处理器调度层次：</strong></p><p>1.长程调度（决定作业是否能创建进程运行、分配资源、创建后是就绪或就绪挂起）</p><p>2.中程调度（将内存调到外存对换区挂起）</p><p>3.短程调度（哪个进程获得处理机）。</p><p><strong>2.调度准则：</strong></p><p>资源（cpu）利用率、平衡资源、响应时间、周转时间、吞吐率、公平性。</p><p><strong>3.处理机调度算法：</strong></p><p>单处理机：先来先服务、时间片轮换、短作业优先、优先级调度、多级反馈队列轮换法。</p><p>多处理机：负载共享调度算法、组调度算法、专用处理机分配调度算法。</p><p><strong>4.实时调度：</strong></p><p>有限等待时间、有限响应时间、用户控制、可靠性高、系统处理错误能力强。算法：频率单调调度算法、时限调度算法、最少裕度法。</p><p><strong>5.短程调度算法</strong></p><p>单处理器调度算法、多处理器调度算法。</p><h3 id="第五章-存储管理"><a href="#第五章-存储管理" class="headerlink" title="第五章 存储管理"></a>第五章 存储管理</h3><p><strong>1.存储管理功能：</strong></p><p>存储空间的分配与回收、地址映射与重定位、存储共享与保护。</p><p><strong>2.存储分配的三种方式：</strong></p><p>1.直接存储分配方式（直接操作物理地址）、</p><p>2.静态存储分配方式（使用逻辑地址，程序一直占据存储空间直到结束）、</p><p>3.动态存储分配方式（一部分一部分动态装入，利用覆盖与交换）。</p><p><strong>3.重定位定义：</strong></p><p>由于用户程序装入而引起的地址空间中的相对地址转化为存储空间中绝对地址的地址变换过程，称为地址重定位。</p><p><strong>4.两种重定位特点与区别：</strong></p><p>1.静态地址重定位是用户程序在装入时由装配程序一次完成，以后不变。</p><p>2.动态地址重定位是程序执行过程中，cpu要对存储器访问时通过硬件地址变换机构将程序和数据地址转换成主存地址，逻辑地址MA&#x3D;(重定位寄存器BR)+(相对地址寄存器VR)。</p><p><strong>5.覆盖与交换：</strong></p><p>1.覆盖指一个用户程序不在一开始把全部程序数据装入主存，把程序划分成若干个相互独立的程序段，让那些不会同时被CPU执行的程序段共享同一个主存区。某一程序段执行时将该程序段装入主存覆盖以前某个程序段。 2.交换指将系统暂时不用的程序数据从主存中调出，腾出更大存储空间将系统要求使用的程序数据调入主存并将控制权转交给它。在主存和外存交换程序数据。</p><p><strong>6.分区存储管理：</strong></p><p>1.固定分区法采用分区说明表将主存的用户可用区域划分为若干个大小不等的区域，每个进程占用一个或多个区域。优缺点：实现简单，但存在内部碎片。</p><p>2.动态分区法在os启动时只存在一个空闲分区。</p><p>3.分配程序将该区域依次划分给调度程序选中的进程，分配的大小随用户进程对主存的要求改变，不会出现碎片。</p><p>4.数据结构：使用可用分区表、自由链表、请求表。</p><p>5.算法使用最先适应法（产生碎片）、最佳适应法（产生碎片）、最坏适应法。</p><p>6.动态分区回收（释放区与上下空闲区是否相邻的情况）。</p><p>7.地址转换：先判断逻辑地址&lt;限长值？（保护：地址越界中断）再用基址寄存器+逻辑地址&#x3D;绝对地址。</p><p>8.共享：各作业共享存储区域部分有相同基址、限长值。</p><p>9.优点：多道程序设计资源利用率高、硬件支持少管理简单。缺点：主存利用率不高、只能覆盖交换。</p><p><strong>7.页式存储管理：</strong></p><p>1.静态分页管理。利用页表、请求表（包含进程号、请求页面数、页表起始地址、页表长度、状态）、存储页框表（位视图、空闲页框链）。</p><p>2.分配：首先从请求表查出进程要求的页框数，由存储页框表检查是否有空闲页框，若有则分配设置页表，填写请求表，查找出空闲页框，将对应页框填入页表。</p><p>3.回收：将页表中的页框插入存储页框表中，使之成为空闲页框。</p><p>4.地址变换：将逻辑地址分为页号和页内偏移，根据页号找到页框号，将页框号和页内偏移拼接。</p><p>5.共享保护：数据共享中，不同作业对共享数据页使用不同页号，各自页表的表目指向共享页框。程序共享必须规定统一页号。</p><p>6.保护：保护保护权限域或保护键法。（psw的键和访问页的保护键核对，相符时能访问）。</p><p>7.优点：解决了碎片问题。缺点：作业大小仍受主存页框数限制。</p><p><strong>8.虚拟存储器：</strong></p><p>1.当用户作业要求存储空间大，不能装入主存时，基于局部性原理，把要用的数据和程序装入主存，暂时不用的驻留在外存。</p><p>2.流程：首先，为用户作业或进程分配主存工作区并填写相应的页表项目;接着，由进程调度程序调度用户进程执行。进程在执行中访问某页时，硬件地转换机构先查看快表，若在快表中命中，则立即形成绝对地址，否则再查看页表，若该页对应的状态位为1,表明该页已在主存，即根据页表内的页框号形成访问主存的绝对地址，将该页的信息登记到快表中。若该页对应的状态位为0,表明该页不在主存中，则由硬件产生一个缺页中断。操作系统内核必须处理这个缺页中断，处理的办法是先查看主存是否有空闲的页框，若有则按该页在外存的地址将该页读出并装人主存，在页表:表中填上它占用的页框号且修改状态位。若主存已没有空闲页框，则必须调出已在主存中的页，再将所需的页装入，对页表和存储页框表进行相应的修改。为了提高系统效率，在访问某页时，若是执行写指令，则在页表中相应页的修改位上置1。这样选择某页调出时，必须看其修改位是否为1,若修改位为1,那么就将该页写回外存中，否则不必把该页重新写回外存中。</p><p><strong>9.段式虚拟存储管理思想：</strong></p><p>把作业的所有分段的副本存放在外存上，当作业被调度投入运行时，首先把当前需要用的一段或几段装入主存，在执行过程中，访问到不在贮存的段时，通过缺段中断机构把它从外存调入。流程：由硬件地址转换机构查快表和段表，若快表命中或该段在主存中，核对存储权限。存储合法，则按静态段式存储管理的地址转换得到绝对地址，否则引发保护中断。若该段不在主存，由硬件产生缺段中断，操作系统处理中断时查看可用分区表或自由链表，找出一个足够大的连续区域装入该分段。若找不到连续分区，则检查空闲区总和，使用移动技术合并一个空闲区将该分段装入主存。若空闲区总和不能满足，则调出段。</p><p><strong>10.常用页面置换算法：</strong></p><p>OPT（理论上）、FIFO、CLOCK、LRU</p><h3 id="第六章-文件管理"><a href="#第六章-文件管理" class="headerlink" title="第六章 文件管理"></a>第六章 文件管理</h3><p><strong>1.文件：</strong></p><p>文件是一组逻辑上相互关联的信息的集合，是计算机系统中信息的一种组织结构。文件的基本操作有创建、删除、写、读、打开、关闭。</p><p><strong>2.文件存取方法</strong></p><p>(文件访问 access)：1.顺序存取方法Sequential access（严格按照数据记录的排列顺序依次存取）、2.直接存取方法Random access（随意读写文件任意位置）、3.索引存取（需要创建文件索引）。</p><p><strong>3.文件逻辑结构：</strong></p><p>1.无结构文件（流式文件、字符流）Byte Sequence。以byte为单位，将数据按顺序组织成记录并积累保存，是有序相关信息项的集合，没有结构。</p><p>2.顺序文件Record Sequence。文件是具有固定长度记录的序列，每个记录有固定内部结构。</p><p>3.索引顺序文件将记录分为若干组，关键字按组排序，为所有组建立一张索引表，每组在索引表中有一个表项包含第一条记录的关键字值和指向该记录的指针。索引可以进行多次，类似于树。</p><p>4.索引文件与索引顺序文件的区别是索引顺序文件一组记录对应一个索引表项，索引文件一个记录对应一个索引表项。5.直接文件（哈希文件）将键值通过哈希函数转换成记录的物理地址。</p><p><strong>4.文件目录(directory)结构：</strong></p><p>1.单级目录结构（single-level directory system）为每个文件建立一张目录表，每个文件的文件控制块(FCB)占有目录表的一个目录项。</p><p>2.两级目录结构(Two level Directory System)为每个用户建立一个文件目录，即用户文件目录(user file directory)。为所有用户文件目录建立一个高层目录主文件目录(main file directory)</p><p>3.树型目录结构(tree structured directory)&#x2F;层次目录结构(Hierarchical Directory system):允许用户创建子目录。根目录的每个目录项可以对应一个文件，也可以对应一个子目录。子目录结构与根目录类似。查找一个文件根据文件的路径完成。</p><p>4.无环图目录结构(Directed Acyclic Graph):同一文件或子目录可出现在不同目录中,使用链接进行文件共享。</p><p><strong>5.文件目录：</strong></p><p>1.文件目录操作：创建、删除、修改、显示、搜索、创建文件、删除文件。</p><p>2.文件控制块：File Control Block FCB。每个文件都有一个与之对应的文件控制块，所有文件的文件控制块按一定方式组合在一起构成文件目录表。每个文件控制块对应目录表中的一个目录项。文件目录在文件名和文件自身提供一种映射。</p><p>3.索引节点：i结点（i-node），将fcb除文件名以外的信息放入i结点，每个文件对应一个索引节点。文件目录中每个目录项仅由文件名和i结点构成，与文件信息分离。</p><p><strong>6.文件共享</strong></p><p>1.符号链接（symbol link）：采用无环图目录结构。系统创建一个link（lnk）类型的文件，新文件中被写入的是被链接文件的路径名。只有文件主才拥有指向其索引结点的指针，其他用户只有路径名。文件主删除文件后其他用户已找不到文件。优点是网络共享时只要文件路径名，缺点是访问共享文件时要多次读盘。</p><p>2.硬链接（hard link）：无环图目录结构。文件的物理地址等属性不在目录项而在inode中，利用链接计数（count）。共享文件时，用户B的目录中新增一个目录项并设置指针指向该文件的索引结点。文件主删除文件时count-1，count为0时文件被删除。</p><p><strong>7.文件保护</strong></p><p>实现文件保密性、完整性、可用性。技术：用户认证、文件保护、数据备份。</p><p><strong>8.文件存储空间管理</strong></p><p>1.空闲表：连续分配，与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。为空闲区建立空闲盘块表，包含序号、首块号、空闲块数（长度）等信息。</p><p>2.空闲链表：storing the free list on a linked list。空闲盘块链将所有空闲盘块连成一条链。空闲盘区链将空闲盘区（每个空闲区可能含多个盘块，自带盘区大小信息）连成一条链。</p><p>3.位示图：bitmap。利用一个二进制位表示存储空间一个盘块状态，某位值为0表示该盘块空闲。</p><p>4.索引链接表法（成组链接法Group link）：每个索引表块第0个表项作为指向下一个索引表块的指针。链表的头指针在超级块中，包括结构和管理两方面信息。把n个空闲扇区地址保存在第一个空闲扇区内。文件分配时从链表头索引块表尾部开始分配，若读入第0表项则将该表项指针读入超级块作为索引链表表头指针，将该盘块分配给请求空闲块的文件。</p><p><strong>9.文件分配</strong></p><p>1.连续分配(contiguous allocation)：创建文件时给文件分配一组连续的物理盘块，一组盘块定义了磁盘上一段线性空间。</p><p>2.链接分配：隐式链接(storing a file as a linked list of disk blocks).文件目录表的每个表项都含有第一盘块的指针和文件长度。每个块第一个字用于指向下一个块的指针。显式链接(linked list allocation using a table in memory)，将用于链接文件的各物理地址指针显式地放在内存的一张链接表中（文件分配表 fat：file allocation table）.</p><p>3.索引分配（索引链接分配inode）：为每个文件分配一个索引表，把分配给该文件的所有盘块号都记录到该索引块中，索引块就是含有盘块号的数组。支持直接访问。</p><h3 id="第七章-I-x2F-O管理"><a href="#第七章-I-x2F-O管理" class="headerlink" title="第七章 I&#x2F;O管理"></a>第七章 I&#x2F;O管理</h3><p><strong>1.I&#x2F;O管理概述：</strong></p><p>1.目标：为用户提供方便、统一的界面，提高资源利用率。</p><p>2.功能：设备控制、设备分配与回收、其他功能。</p><p>3.组成：设备、控制器、通路、（应用接口）。</p><p><strong>2.I&#x2F;O控制方式：</strong></p><p>1.程序直接控制方式（查询）。</p><p>2.中断。</p><p>3.DMA（参数准备、DMA工作（发DMA请求，并用DMA控制器控制总线）、结束中断）。传送数据块，直接将数据存入内存不经过cpu。</p><p>4.通道（独立于CPU的I&#x2F;O处理机，控制设备与内存直接数据交换，有自己的指令系统）</p><p><strong>3.I&#x2F;O缓冲</strong></p><p>1.引入原因：缓解CPU与I&#x2F;O设备之间速度不匹配的矛盾，提高CPU与I&#x2F;O设备之间的并行性。减少对CPU中断频率，放宽对中断响应时间限制。</p><p>2.单缓冲：用户进程发出I&#x2F;O请求时操作系统分配一个位于内存中系统部分的缓冲区。读操作时输入数据被放到缓冲区中，缓冲区已满时进程把缓冲区数据移到用户空间。I&#x2F;O请求为写操作时进程将输出数据放到缓冲区，缓冲区已满时数据输出到I&#x2F;O上。只能有一个进程输入输出。</p><p>3.双缓冲：在进程对一个缓冲区传送数据时，操作系统清空另一个缓冲区。</p><p>4.循环缓冲：多个缓冲区连接起来构成循环缓冲区，一部分用于输入，另一部分用于输出。实现多个设备间、I&#x2F;O设备与CPU的并行工作能力。</p><p>5.缓冲池：由输入缓冲队列、空缓冲队列、输出缓冲队列组成。还有收容输入缓冲区、收容输出缓冲区、提取输入缓冲区、提取输出缓冲区。进程输入时把空缓冲队列队首摘下一个空缓冲区收容输入，输入完成后把它挂到输入队列队尾。同理，进程输出时…收容输出，输出完成后…输出队列队尾。提取输入数据时从输入队列取得一个缓冲区作为工作缓冲区，进程提取数据，用完后挂到空缓冲区队尾。同理，提取输出时从输出队列…</p><p><strong>4.设备驱动程序</strong></p><p>1.模式：作为内核过程实现，与文件系统一起把设备作为特殊文件处理。或作为独立I&#x2F;O进程实现。</p><p>2.功能：1.把抽象要求转为具体要求。2.检查I&#x2F;O命令合法性。3.发I&#x2F;O命令。4.相应中断请求。5.自动构成通道程序</p><p>3.特点：是请求I&#x2F;O设备与设备控制器的通信程序。与I&#x2F;O设备特性紧密相关，与I&#x2F;O控制方式紧密相关，基本部分固化在ROM中。</p><p>4.处理过程：将抽象要求转化为具体要求，检查合法性，读出检查设备状态，传送必要参数，设置工作方式，启咏I&#x2F;O设备。</p><p><strong>5.设备分配</strong></p><p>1.原则：提高利用率避免死锁、方便用户使用（设备无关性）。</p><p>2.分配方式：静态分配、动态分配。</p><p>3.安全性：安全分配方式指进程发出I&#x2F;O请求后进入阻塞，直到I&#x2F;O操作完成后被唤醒。不安全分配方式指发出I&#x2F;O请求后又在需要时继续发出请求，当请求设备被另一进程占用时阻塞，可能产生死锁。</p><p>4.逻辑设备名到物理设备名映射：将用户程序和具体物理设备隔离。用逻辑设备表LUT将逻辑设备名映射为物理设备名。</p><p>5.数据结构：设备控制表（DCT）记录本设备状态、控制器控制表指针、设备队列队首指针、重复执行次数。控制器控制表（COCT）记录控制器状态信息和通道的连接情况。通道控制表（CHCT）记录通道状态和设备控制器连接情况。系统设备表（SDT）记录全部设备信息。</p><p>6.流程：分配设备、分配控制器、分配通道。</p><p>7.SPOOLing(Simultaneous Peripheral Operation On-Line)组成：输入设备输出设备、输入缓冲区输出缓冲区（在内存）、输入井输出井（在磁盘）。作业前先通过输入程序将输入数据存放到输入井，预输入。作业中使用输入数据时从输入井获取。输出时先将数据输出到输出井，输出进程把数据从输出井传送到输出缓冲区，最后输出到输出设备。</p><p><strong>6.磁盘阵列(RAID)：</strong></p><p>把多个磁盘组合成一个磁盘阵列组。作为独立系统在主机外连接。磁盘阵列内有缓冲存储器。提高传输速率、提供校验功能。</p><p><strong>7.时钟电源管理：</strong></p><p><strong>8.磁盘存储器的管理 常用调度算法</strong></p><p>FCFS、SSTF、SCAN 、LOOK、C-SCAN</p><h3 id="第八章-操作系统安全性"><a href="#第八章-操作系统安全性" class="headerlink" title="第八章 操作系统安全性"></a>第八章 操作系统安全性</h3><p><strong>1.文件保护：</strong></p><p>口令保护、加密保护、访问控制。</p><p><strong>2.存取控制表（ACL）：</strong></p><p>为每个文件和目录增加存取控制表（访问控制列表），规定每个用户名及其权限（读、写、执行）。权能表将存取矩阵按行存放，每个主体都被赋予一张可访问的客体表与权限。</p><p><strong>3.三个特性</strong></p><p>保密性、完整性、可用性</p><p><strong>4.操作系统的安全性是计算机系统安全的基础</strong></p><p>有选择的访问控制、内存管理与对象重用、审计能力、文件和数据的加密以及进程间安全通信机制。</p><p><strong>5.保护机制</strong></p><p>保护域、ACL、权能表</p><p><strong>6.安全机制：</strong></p><p>用户认证；恶意代码及时防范、发现和清除；使用情况的监控和审计；加密技术；备份。</p><h3 id="第九章-新型操作系统"><a href="#第九章-新型操作系统" class="headerlink" title="第九章 新型操作系统"></a>第九章 新型操作系统</h3><p><strong>1.嵌入式操作系统</strong></p><p>微软嵌入式操作系统、嵌入式linux与安卓、TinyOs、VxWorks</p><p><strong>2.多媒体操作系统</strong></p><p><strong>3.分布式操作系统</strong></p><p>集群系统、MapReduce计算模型</p><p><strong>4.虚拟化技术</strong></p><h3 id="第十章-操作系统设计问题"><a href="#第十章-操作系统设计问题" class="headerlink" title="第十章 操作系统设计问题"></a>第十章 操作系统设计问题</h3><p><strong>1.操作系统设计目标</strong></p><p>抽象定义、原语操作提供、隔离性保证、硬件管理（TinyOs）</p><p><strong>2.界面设计</strong></p><p>界面设计的原则、界面设计的范式、系统调用界面</p><p><strong>3.操作系统设计实现</strong></p><p><strong>4.性能优化</strong></p><p><strong>5.项目管理</strong></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;江苏大学-操作系统-知识点提纲-期末考试-x2F-考研-复习&quot;&gt;&lt;a href=&quot;#江苏大学-操作系统-知识点提纲-期末考试-x2F-考研-复习&quot; class=&quot;headerlink&quot; title=&quot;江苏大学 操作系统 知识点提纲 期末考试&amp;#x2F;考研 复习&quot;&gt;&lt;/a&gt;江苏大学 操作系统 知识点提纲 期末考试&amp;#x2F;考研 复习&lt;/h2&gt;&lt;p&gt;基于江苏大学教材《操作系统设计原理（第二版）》，科学出版社出版。詹永照、薛安荣主编。&lt;/p&gt;
&lt;p&gt;部分内容与考试考点与王道考研等参考资料略有区别，请自行区分。&lt;/p&gt;
&lt;h3 id=&quot;选择题微信小程序刷题&quot;&gt;&lt;a href=&quot;#选择题微信小程序刷题&quot; class=&quot;headerlink&quot; title=&quot;选择题微信小程序刷题&quot;&gt;&lt;/a&gt;选择题微信小程序刷题&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://tu.my/i/2022/06/15/62a9dba0c9d8d.png&quot;&gt;请点击这里&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：小程序用于学习通题目练习,与下面的知识提纲无关&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目录&lt;/p&gt;
&lt;p&gt;第一章 绪论&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>软件工程题库</title>
    <link href="https://qgdd.vercel.app/2022/05/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%A2%98%E5%BA%93/"/>
    <id>https://qgdd.vercel.app/2022/05/31/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E9%A2%98%E5%BA%93/</id>
    <published>2022-05-31T13:48:49.000Z</published>
    <updated>2022-06-07T08:45:02.332Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件工程期末题库整理-仅供参考"><a href="#软件工程期末题库整理-仅供参考" class="headerlink" title="软件工程期末题库整理(仅供参考)"></a>软件工程期末题库整理(仅供参考)</h1><blockquote><p>欢迎来寻找bug,在评论区留言~</p></blockquote><h2 id="点击前往微信小程序刷题："><a href="#点击前往微信小程序刷题：" class="headerlink" title="点击前往微信小程序刷题："></a>点击前往微信小程序刷题：</h2><p><a href="https://tu.my/i/2022/06/06/629df0e066ed1.png">我爱刷题-软件工程题库</a></p><h2 id="一、判断题"><a href="#一、判断题" class="headerlink" title="一、判断题"></a>一、判断题</h2><blockquote><p>特别感谢某大佬和杨群大佬找出错误。</p></blockquote><ol><li><p>软件就是程序，编写软件就是编写程序。 （X ）</p></li><li><p>软件危机的主要表现是软件需求增加，软件价格上升。 （ X ）</p></li><li><p>软件工程学科出现的主要原因是软件危机的出现。 （ √ ）</p></li><li><p>瀑布模型的最大优点是将软件开发的各个阶段划分得十分清晰。 ( X )</p><span id="more"></span></li><li><p>原型化开发方法包括生成原型和实现原型两个步骤。 (X )</p></li><li><p>软件过程改进也是软件工程的范畴。 ( √ )</p></li><li><p>在软件开发中采用原型系统策略的主要困难是成本问题。 ( X )</p></li><li><p>需求规格说明书在软件开发中具有重要的作用，它也可以作为软件可行性分析的依据。( X )</p></li><li><p>需求分析的主要目的是解决软件开发的具体方案。 ( X )</p></li><li><p>需求规格说明书描述了系统每个功能的实现。 ( X )</p></li><li><p>非功能需求是从各个角度对系统的约束和限制,反映了应用对软件系统质量和特性的额外要求。 ( √ )</p></li><li><p>需求评审人员主要由开发人员组成，一般不包括用户。 ( X )</p></li><li><p>分层的DFD图可以用于可行性分析阶段，描述系统的物理结构。 ( X )</p></li><li><p>信息建模方法是从数据的角度来建立信息模型的，最常用的描述信息模型的方法是E-R图。 ( √ )</p></li><li><p>用于需求分析的软件工具，应该能够保证需求的正确性，即验证需求的一致性、 完整性、现实性和有效性。 ( √ )</p></li><li><p>需求分析是开发方的工作，用户的参与度不大。 ( X )</p></li><li><p>软件设计说明书是软件概要设计的主要成果。 ( X )</p></li><li><p>软件设计中设计复审和设计本身一样重要，其主要作用是避免后期付出高昂代价。( √ )</p></li><li><p>划分模块可以降低软件的复杂度和工作量，所以应该将模块分得越小越好。 ( X )</p></li><li><p>SD法是一种面向数据结构的设计方法，强调程序结构与问题结构相对应。 ( X )</p></li><li><p>判定表的优点是容易转换为计算机实现，缺点是不能够描述组合条件。 ( X )</p></li><li><p>模块独立要求高耦合低内聚。 ( X )</p></li><li><p>程序设计语言是指编程时表现出来的特点、习惯、逻辑思维等。 ( X )</p></li><li><p>进行程序设计语言的选择时，首先考虑的是应用领域。 ( √ )</p></li><li><p>好程序的一个重要标准是源程序代码的逻辑简明清晰、易读易懂。 ( √ )</p></li><li><p>软件测试的目的是尽可能多地发现软件中存在的错误，将它作为纠错的依据。( √ )</p></li><li><p>测试用例由输人数据和预期的输出结果两部分组成。 ( √ )</p></li><li><p>白盒测试是结构测试，主要以程序的内部逻辑为基础设计测试用例。 ( √ )</p></li><li><p>软件测试的目的是证明软件是正确的。 ( X )</p></li><li><p>单元测试通常应该先进行”人工走查”，再以白盒法为主，辅以黑盒法进行动态测试。( √ )</p></li><li><p>白盒法是一种静态测试方法，主要用于模块测试。 ( X )</p></li><li><p>在等价分类法中，为了提高测试效率，一个测试用例可以覆盖多个无效等价类。( X )</p></li><li><p>发现错误多的模块，残留在模块中的错误也多。 ( √ )</p></li><li><p>类是指具有相同或相似性质的对象的抽象，类的具体化就是对象。 （ √ ）</p></li><li><p>继承性是父类和子类之间共享数据结构和消息的机制，这是类之间的一种关系。（ X ）</p></li><li><p>多态性增强了软件的灵活性和重用性，允许用更为明确、易懂的方式去建立通用软件， 多态性和继承性相结合使软件具有更广泛的重用性和可护充性。 （ √ ）</p></li><li><p>类的设计过程包括:确定类，确定关联类，确定属性，识别继承关系。 （ √ ）</p></li><li><p>用面向对象方法开发的软件系统，可维护性好。 （ √ ）</p></li><li><p>模型是对现实的简化，建模是为了更好地理解所开发的系统。 （ √ ）</p></li><li><p>多态性防止了程序相互依赖而带来的变动影响。 （ X ）</p></li><li><p>类封装比对象封装更具体、更细致。 （ X ）</p></li><li><p>面向对象的继承性是子类自动共享父类数据结构和方法的机制。 （ √ ）</p></li><li><p>面向对象的开发方法将过程作为最基本的元素，是分析问题、解决问题的核心。( X )</p></li><li><p>用例需求分析方法采用的是一种结构化的情景分析方法，即是一种基于场景建模的方法 ( X )</p></li><li><p>面向对象分析方法认为系统是对象的集合，是以功能和数据为基础的。 ( √ )</p></li><li><p>面向对象分析的核心在于建立一个描述软件系统的模型 。 ( X )</p></li><li><p>面向对象的分析过程主要包括三项内容:理解、表达和验证。 ( √ )</p></li><li><p>面向对象分析就是抽取和整理用户需求并建立问题域精确模型的过程。 ( √ )</p></li><li><p>面向对象的方法是以类作为最基本的元素，它是分析问题、解决问题的核心。( X )</p></li><li><p>功能模型是类似编译器之类系统的主要模型。 ( √ )</p></li><li><p>软件设计一般分为总体设计和详细设计，它们之间的关系是全局和局部。 ( √ )</p></li><li><p>在面向对象的设计中，应遵循的设计准则除了模块化、抽象、低耦合、高内聚以外，还有信息隐藏。 ( √ )</p></li><li><p>一个设计得好的软件系统具有低内聚、高耦合的特征。 ( X )</p></li><li><p>面向对象分析和设计活动是一个多次反复迭代的过程。 ( √ )</p></li><li><p>关系数据库可以完全支持面向对象的概念，面向对象设计中的类可以直接对应到关系数据库中的表。 (X)</p></li><li><p>用户界面设计对于一个系统的成功是至关重要的，一个设计得很差的用户界面可能导致用户拒绝使用该系统。 ( √ )</p></li><li><p>一般来说，应该尽量选用面向对象语言来实现面向对象分析、设计的结果。 ( √ )</p></li><li><p>良好的面向对象程序设计风格，既包括传统的程序设计风格准则，也包括为适应面向对象方法所特有的概念( 如继承性)而必须遵循的一些新准则。 ( √ )</p></li><li><p>面向对象测试用例的设计由软件的输入--处理--输出视图或单个模块的算法细节驱动。 ( X )</p></li><li><p>面向对象系统的确认测试是面向白盒的，并且可以应用传统的白盒方法完成测试工作。 ( X )</p></li><li><p>UML是一种建模语言，是一种标准的表示，是一种方法。 ( X )</p></li><li><p>泳道是一种分组机制，它描述了状态图中对象所执行的活动。 ( √ )</p></li><li><p>类图中的角色是用于描述该类在关联中所扮演的角色和职责的。 ( √ )</p></li><li><p>类图用来表示系统中类与类之间的关系,它是对系统动态结构的描述。 ( X )</p></li><li><p>用例模型的基本组成部件是用例、角色和用例之间的联系。 ( √ )</p></li><li><p><strong>用例之间有扩展、使用、组合等几种关系。 ( X )</strong></p></li><li><p>顺序图描述对象之间的交互关系，重点描述对象间消息传递的时间顺序。 ( √ )</p></li><li><p>活动图显示动作及其结果，着重描述操作实现中所完成的工作，以及用例实例或类中的活动。 ( X )</p></li><li><p>UML 语言支持面向对象的主要概念，并与具体的开发过程相关。 ( X )</p></li><li><p>部署图描述系统硬件的物理拓扑结构以及在此结构上执行的软件。 ( √ )</p></li><li><p>代码行技术是比较简单的定量估算软件规模的方法。 ( √ )</p></li><li><p>功能点技术依据对软件信息域特性和软件复杂性的评估结果，估算软件规模。( √ )</p></li><li><p>民主制程序员组的一-个重要特点是，小组成员完全平等，享有充分民主，通过协商做出技术决策。 ( √ )</p></li><li><p>主程序员组的两个关键特性是专业化和层次性。 ( √ )</p></li><li><p>现代程序员组中，技术组长既对技术工作负责，又负责非技术事务。 ( X )</p></li><li><p>总体上说，软件工程文档可以分为用户文档、开发文档和管理文档三类。 ( √ )</p></li><li><p>文档是影响软件可维护性的决定因素。 ( √ )</p></li><li><p>适应性维护是在软件使用过程中，用户会对软件提出新的功能和性能要求，为了满足这些新的要求而对软件进行修改，使之在功能和性能上得到完善和增强的活动。 ( X )</p></li><li><p>进行软件维护活动时，直接修改程序，无需修改文档。 ( X )</p></li><li><p>软件生命周期的最后一个阶段是书写软件文档。 ( X )</p></li></ol><h2 id="二、选择题"><a href="#二、选择题" class="headerlink" title="二、选择题"></a>二、选择题</h2><p>1.在下列选项中，（ D ）不是软件的特征。</p><p>A.系统性与复制性 B.可靠性与一致性</p><p>C.抽象性与智能性 D.有形性与可控性</p><p>2.软件危机的主要原因是（ D ）。</p><p>A.软件工具落后 B.软件生产能力不足</p><p>C.对软件的认识不够 D.软件本身的特点及开发方法</p><p>3.下列说法中正确的是（ B ）。</p><p>A.20世纪50年代提出了软件工程的概念</p><p>B.20世纪60年代提出了软件工程的概念</p><p>C.20 世纪70年代出现了客户机&#x2F;服务器技术</p><p>D.20世纪80年代软件工程学科达到成熟</p><p>4.( C )是将系统化的、规范的、可定量的方法应用于软件的开发、运行和维护的过程，它包括方法、工具和过程三个要素。</p><p>A.软件生命周期 B. 软件测试 C.软件工程 D.软件过程</p><p>5.在下列选项中, (A )不属于软件工程学科所要研究的基本内容。</p><p>A.软件工程材料 B.软件工程目标 C.软件工程原理 D. 软件工程过程</p><p>6.软件工程的三要素是( C)。</p><p>A.技术、方法和工具 B. 方法、对象和类</p><p>C.方法、工具和过程 D.过程、模型和方法</p><p>7.用来辅助软件开发、运行、维护、管理、支持等过程中的活动的软件称为软件开发工具，通常也称为( D) 工具。</p><p>A. CAD B. CAI C. CAM D. CASE</p><p>8.软件生命周期模型不包括( B )。</p><p>A.瀑布模型 B.用例模型 C.增量模型 D.螺旋模型</p><p>9.包含风险分析的软件工程模型是( D )。</p><p>A.喷泉模型 B.瀑布模型 C.增量模型 D.螺旋模型</p><p>10.软件过程是( C )。</p><p>A.特定的开发模型 B.一种软件求解的计算逻辑</p><p>C.软件开发活动的集合 D.软件生命周期模型</p><p>11.软件工程中描述生命周期的瀑布模型一般包括计划、需求分析、设计、编码、( D )、维护等几个阶段。</p><p>A.产品发布 B.版本更新 C.可行性分析 D.测试</p><p>12.软件开发的瀑布模型，一般都将开发过程划分为:分析、设计、编码和测试等阶段，一般认为可能占用人员最多的阶段是(C )。</p><p>A.分析阶段 B.设计阶段 C.编码阶段 D.测试阶段</p><p>13.增量模型本质上是一种(C )。</p><p>A.线性顺序模型 B.整体开发模型 C.非整体开发模型 D.螺旋模型</p><p>14.螺旋模型综合了(B ) 的优点，并增加了风险分析。</p><p>A.增量模型和喷泉模型 B.瀑布模型和演化模型</p><p>C.演化模型和喷泉模型 D.原型和喷泉模型</p><p>15. CMM模型将软件过程的成熟度分为5个等级。在( B) 使用定量分析来不断地改进和管理软件过程。</p><p>A.管理级 B.优化级 C.定义级 D.可重复级</p><p>16.需求工程的主要目的是(C )。</p><p>A.系统开发的具体方案 B.进一步确定用户的需求</p><p>C.解决系统是”做什么的问题” D.解决系统是”如何做的问题&quot;</p><p>17.需求分析的主要方法有( C)。</p><p>A.形式化分析方法 B.PAD 图描述</p><p>C.结构化分析SA方法 D.程序流程图</p><p>18.SA法的主要描述手段有(B )。</p><p>A.系统流程图和模块图 B.DFD图、数据词典、加工说明</p><p>C.软件结构图、加工说明 D.功能结构图、加工说明</p><p>19.画分层DFD图的基本原则有( C)。</p><p>A.数据守恒原则 B.分解的可靠性原则</p><p>C.子、父图平衡的原则 D.数据流封闭的原则</p><p>20.在E-R模型中，包含以下基本成分(D )。</p><p>A.数据、对象、实体 B.控制、关系、对象</p><p>C.实体、关系、控制 D.实体、属性、关系.</p><p>21.在下面的叙述中哪一个不是软件需求分析的任务? ( C )。</p><p>A.问题分解 B.可靠性与安全性要求</p><p>C.结构化程序设计 D.确定逻辑模型</p><p>22.需求规格说明书的作用不应包括(D )。</p><p>A.软件设计的依据 B.用户与开发人员对软件要做什么的共同理解</p><p>C.软件验收的依据 D.软件可行性研究的依据</p><p>23.软件需求规格说明书的内容不应该包括( B)。</p><p>A.对重要功能的描述 B.对算法的详细过程描述</p><p>C.对数据的要求 D.软件的性能</p><p>24.软件需求分析阶段的工作，可以分为以下4个方面:对问题的识别、分析与综合、编写需求分析文档以及(C )。</p><p>A.总结 B.阶段性报告</p><p>C.需求分析评审 D.以上答案都不正确</p><p>25.下述任务中， 不属于软件工程需求分析阶段的是(D )。</p><p>A.分析软件系统的数据要求 B.确定软件系统的功能需求</p><p>C.确定软件系统的性能要求 D.确定软件系统的运行平台</p><p>26.进行需求分析可使用多种工具,但(B )是不适用的。</p><p>A.数据流图 B. PAD图 C.状态转换图 D. 数据词典</p><p>27.在需求分析之前有必要进行(B ) 工作。</p><p>A.程序设计 B.可行性分析 C.ER分析 D.2NF分析</p><p>28.数据流图是进行软件需求分析的常用图形工具，其基本图形符号是(C )。</p><p>A.输人、输出、外部实体和加工 B. 变换、加工、数据流和存储</p><p>C.加工、数据流、数据存储和外部实体 D. 变换、数据存储、加工和数据流</p><p>29.在结构化分析方法中，用以表达系统内数据的运动情况的工具是( A )。</p><p>A.数据流图 B.数据字典 C.结构化语言 D.判定表与判定树</p><p>30.为了提高模块的独立性，模块之间最好是(C )。</p><p>A.公共环境耦合 B.控制耦合 C.数据耦合 D.特征耦合</p><p>31.在面向数据流的软件设计方法中，一般将信息流分为( D)。</p><p>A.数据流和控制流 B.变换流和控制流 C.事务流和控制流 D.变换流和事务流</p><p>32.模块独立性是软件模块化所提出的要求，衡量模块独立性的度量标准是模块的(A )。</p><p>A.内聚性和耦合性 B.局部化和封装化 C.抽象和信息隐藏 D.逐步求精和结构图</p><p>33.模块的独立性是由内聚性和耦合性来度量的，其中内聚性是( C )。</p><p>A.模块间的联系程度 B.信息隐藏程度 C.模块的功能强度 D.接口的复杂程度</p><p>34.当算法中需要用一个模块去计算多种条件的复杂组合.并根据这些条件完成适当的功能时，从供选择的答案中，选出合适的描述工具。( D)</p><p>A.程序流程图 B.N-S 图 C.PAD图 D.判定表</p><p>35.面向数据流的软件设计方法可将( C)映射成软件结构。</p><p>A.控制结构 B.模块 C.数据流 D.事物流</p><p>36.Jackson 方法根据( C )来导出程序结构。</p><p>A.数据流图 B.数据间的控制结构 C.数据结构 D. IPO图</p><p>37.程序语言的特性包括(B)。</p><p>A.习惯特性 B.算法特性 C.工程特性 D.技术特性</p><p>38.软件实现是软件产品由概念到实体的一个 关键过程,它将(A )的结果翻译成用某种程序设计语言编写的并且最终可以运行的程序代码。虽然软件的质量取决于软件设计，但是规范的程序设计风格将会对后期的软件维护带来不可忽视的影响。</p><p>A.软件设计 B.详细设计 C.架构设计 D.总体设计</p><p>39.成功的测试是指运行测试用例后（ A ）</p><p>A.发现了程序错误 B.未发现程序错误 C.证明程序正确 D.改正了程序错误</p><p>40.白盒测试法是根据程序的( B) 来设计测试用例的方法。</p><p>A.输出数据 B.内部逻辑 C.功能 D.输人数据</p><p>41.软件的集成测试工作最好由(C )承担，以提高集成测试的效果。</p><p>A.该软件的设计人员 B.该软件开发组的负责人</p><p>C.不属于该软件开发组的软件设计人员 D.该软件的编程人员</p><p>42.黑盒测试是从(C )观点的测试，白盒测试是从( )观点的测试。</p><p>A.开发人员、管理人员 B.用户、管理人员</p><p>C.用户、开发人员 D.开发人员、用户</p><p>43.软件测试可能发现软件中的( D ), 但不能证明软件( )。</p><p>A.所有错误、没有错误 B.设计错误、没有错误</p><p>C.逻辑错误、没有错误 D.错误、没有错误</p><p>44.软件测试的目的是(D )。</p><p>A.证明软件的正确性 B.找出软件系统中存在的所有错误</p><p>C.证明软件系统中存在错误 D.尽可能多的发现软件系统中的错误</p><p>45.使用白盒测试方法时确定测试数据应根据( A)和指定的覆盖标准。</p><p>A.程序的内部逻辑 B.程序的复杂程度</p><p>C.程序的难易程度 D.程序的功能</p><p>46.黑盒测试方法根据(B )设计测试用例。</p><p>A.程序的调用规则 B.软件要完成的功能</p><p>C.模块间的逻辑关系 D.程序的数据结构</p><p>47.在软件测试中，逻辑覆盖标准主要用于(A )。</p><p>A.白盒测试方法 B.黑盒测试方法</p><p>C.灰盒测试方法 D.回归测试方法</p><p>48.集成测试的主要方法有两个，一个是(C )一个是( )。</p><p>A.白盒测试方法、黑盒测试方法 B.等价类划分方法、边缘值分析方法</p><p>C.渐增式测试方法、非渐增式测试方法 D.因果图方法、错误推测方法.</p><p>49.验收测试的任 务是验证软件的(D )。</p><p>A.可靠性 B.正确性 C.移植性 D.有效性</p><p>50.软件测试的目的是尽可能发现软件中的错误，通常(D ) 是代码编写阶段可进行的测试，它是整个测试工作的基础。</p><p>A.集成测试 B.系统测试 C.验收测试 D. 单元测试</p><p>51.汽车有一个发动机，汽车和发动机之间的关系是( B ) 关系。</p><p>A.组装 B.整体部分 C.分类 D. 一般具体</p><p>52.(D ) 是把对象的属性和操作结合在一一起， 构成-个独立的对象，其内部信息对外界是隐藏的，外界只能通过有限的接口与对象发生联系。</p><p>A.多态性 B.继承 C.消息 D.封装</p><p>53. ( B) 意味着一个操作在不同的类中可以有不同的实现方式。</p><p>A.多继承 B.多态性 C.消息 D.封装</p><p>54.每个对象可用它自己的一组属性和它可以执行的一组(A )来表征。</p><p>A.操作 B.功能 C.行为 D.数据</p><p>55.应用执行对象的操作可以改变该对象的( C)。</p><p>A.行为 B.功能 C.属性 D.数据</p><p>56.面向对象的主要特征除了对象唯一性、封装性、继承性外,还有( D)。</p><p>A.兼容性 B.完整性 C.可移植性 D.多态性</p><p>57.关联是建立( B )之间关系的一种手段。</p><p>A.对象 B.类 C.功能 D.属性</p><p>58.面向对象软件技术的许多强有力的功能和突出的优点，都来源于把类组织成一个层次结构的系统，一个类的上层可以有父亲，下层可以有子类，这种层次结构系统的一个重要性质是 ( B ),一个类可获得其父亲的全部描述(数据和操作)。</p><p>A.兼容性 B.继承性 C.复用性 D.多态性</p><p>59.所有的对象可以成为各种对象类， 每个对象类都定义了一组(D )。</p><p>A.说明 B.类型 C.过程 D.方法</p><p>60.通过执行对象的操作改变对象的属性，但它必须通过( B )的传递。</p><p>A.操作 B.消息 C.信息 D.继承</p><p>61. 下列不属于面向对象的要素有( C)。</p><p>A.继承 B.抽象 C.分类性 D.封装</p><p>62.面向对象分析的首要工作是建立(D )。</p><p>A.系统的动态模型 B.系统的功能模型</p><p>C.基本的E-R模型 D.问题的对象模型</p><p>63.面向对象的分析方法主要是建立三类模型，即( B).</p><p>A.系统模型、ER模型、应用模型 B.对象模型、动态模型、功能模型</p><p>C.ER模型、对象模型、功能模型 D.对象模型、动态模型、应用模型</p><p>64.软件开发过程中，抽取和整理用户需求并建立问题域精确模型的过程叫( C )。</p><p>A.生命周期 B.面向对象设计 C.面向对象分析 D.面向对象程序设计</p><p>65.面向对象分析阶段建立的3个模型中，核心的模型是( C) 模型。</p><p>A.功能 B.动态 C.对象 D.分析</p><p>66.面向对象分析是对系统进行(C)的一一种方法。</p><p>A.设计评审 B.程序设计 C.需求建模 D.测试验收</p><p>67.应该在( B )，确定对象类中应有的服务。</p><p>A.建立对象模型之时 B.建立动态模型和功能模型之后</p><p>C.建立功能模型之后 D.建立动态模型之后</p><p>68.面向对象的动态模型中，每张状态图表示(A ) 的动态行为。</p><p>A.某一个类 B.有关联的若干个类 C.一系列事件 D.一系列状态</p><p>69.在考察系统的-些涉及时序和改变的状况时，要用动态模型来表示。动态模型着重于系统的控制逻辑，它包括两个图:一个是事件追踪图，另一个是( B)。</p><p>A.顺序图 B.状态图 C.系统结构图 D.数据流图</p><p>70.动态模型的描述工具是( C)。</p><p>A.设计图 B.结构图 C.状态图 D.对象图</p><p>71.对象模型的描述工具是( D )。</p><p>A.状态图 B.数据流图 C.结构图 D.对象图</p><p>72.功能模型中所有的( D)往往形成一个层次结构，在这个层次结构中一个数据流图的过程可以由下一层数据流图做进一步的说明。</p><p>A.事件追踪图 B.物理模型图 C.状态迁移图 D.数据流图</p><p>73.只有类的共有界面的成员才能成为使用类的操作，这是软件设计的(B)原则。</p><p>A.过程抽象 B.信息隐藏 C.功能抽象 D.共享性</p><p>74.(B) 是表达系统类及其相互联系的图示，它是面向对象设计的核心，是建立状态图、</p><p>协作图和其他图的基础。</p><p>A.部署图 B.类图 C.组件图 D.配置图</p><p>75.下面所列的性质中，(D)不属于面向对象程序设计的特性。</p><p>A.继承性 B.重用性 C.封装性 D.可视化</p><p>76.下列是面向 对象设计方法中有关对象的叙述，其中(B ) 是正确的。</p><p>A.对象在内存中没有它的存储区 B.对象的属性集合是它的特征表示</p><p>C.对象的定义与程序中类型概念相当 D.对象之间不能相互通信</p><p>77.面向对象程序设计中，基于父类创建的子类具有父类的所有特性(属性和方法),这一特点称为类的( C)。</p><p>A.多态性 B.封装性 C.继承性 D.重用性</p><p>78.面向对象设计00D模型的主要部件中，通常不包括(A)</p><p>A.通信部件 B.人机交互部件 C.任务管理 D.数据管理</p><p>79.面向对象设计时，对象信息的隐藏主要是通过(A ) 实现的。</p><p>A.对象的封装性 B.子类的继承性 C.系统模块化 D.模块的可重用</p><p>80.面向对象设计阶段的主要任务是系统设计和(D )。</p><p>A.结构化设计 B.数据设计 C.面向对象程序设计 D.对象设计</p><p>81.面向对象的实现主要包括( A)。</p><p>A.把面向对象设计用某种程序设计语言书写为面向对象程序,测试并调试面向对象的程序</p><p>B.面向对象设计</p><p>C.选择面向对象语言</p><p>D.单元测试</p><p>82.面向对象程序设计语言不同于其他语言的最主要特点是( C)。</p><p>A.模块性 B.抽象性 C.继承性 D.内聚性</p><p><strong>83.面向对象的测试与传统测试方法的主要区别是 ( A C )。[不确定] [老师说不考]</strong></p><p>A.面向对象的测试可在编码前进行，传统测试方法在编码后进行</p><p>B.面向对象的测试以需求和设计阶段的测试为主，不需要进行代码测试</p><p>C.测试对象不同</p><p>D.面向对象的测试不需要设计测试用例，只需要进行会议评审</p><p>84.UML是软件开发中的一个重要T具，它主要应用于(D )。</p><p>A.基于螺旋模型的结构化方法 B. 基于需求动态定义的原型化方法</p><p>C.基于数据的数据流开发方法 D.基于对象的面向对象的方法</p><p>85.( C) 是从用户使用系统的角度描述系统功能的图形表达方法。</p><p>A.类图 B.活动图 C.用例图 D.状态图</p><p>86.( A) 是表达系统类及其相互联系的图示，它是面向对象设计的核心，是建立状态图、</p><p>协作图和其他图的基础。</p><p>A.类图 B.状态图 C.对象图 D.部署图</p><p>87.(B ) 描述了一组交互对象间的动态协作关系，它表示完成某项行为的对象和这些对象之间传递消息的时间顺序。</p><p>A.类图 B.顺序图 C.状态图 D.协作图</p><p>88.(C)是用于表示构成分布式系统的节点集和节点之间的联系的图示，它可以表示系统</p><p>中软件和硬件的物理架构。</p><p>A.组件图 B.类图 C.部署图 D.状态图</p><p>89.(A)定义了系统的功能需求，它是从系统的外部看系统功能，并不描述系统内部对功</p><p>能的具体实现。</p><p>A.用例图 B.类图 C.活动图 D.对象图</p><p>90.状态图包括( D )。</p><p>A.类的状态和状态之间的转换 B.触发类动作的事件</p><p>C.类执行的动作 D.所有以上选项</p><p>91. ( B) 的作用是为有效地、定量地进行管理，把握软件工程过程的实际情况和它所产生的产品质量,</p><p>A.估算 B.度量 C.风险分析 D.进度安排</p><p>92.LOC和FP是两种不同的估算技术，但两者有许多共同的特征，只是LOC和FP技术对于分解所需要的( A) 不同。</p><p>A.详细程度 B.分解要求 C.使用方法 D.改进过程</p><p>93.项目团队原来有6个成员，现在又增加了6个成员，这样沟通渠道增加了多少? ( A )</p><p>A.4.4倍 B.2倍 C. 6倍 D.6条</p><p>94. Mantei 提出了3种通用的项目组组织方式:民主分权式、控制分权式、( D )。</p><p>A.启发式 B.归纳式 C.总结式 D.控制集权式</p><p>95.下列哪项不是风险管理的过程?( D)</p><p>A.风险规划 B.风险识别 C.风险评估 D.风险收集</p><p>96.按照软件配置管理的原始指导思想，受控制的对象应是( C)。</p><p>A.软件过程 B.软件项目 C.软件配置项 D.软件元素</p><p>97.在软件维护的内容中，占维护活动工作量比例最高的是(D )。</p><p>A.纠错性维护 B.适应性维护 C.预防性维护 D.完善性维护</p><p>98.使用软件时提出增加新功能就必须进行(C ) 维护。</p><p>A.预防性 B.适应性 C.完善性 D.纠错性</p><p>99.软件文档是软件工程实施的重要成分，它不仅是软件开发各阶段的重要依据,而且也影响软件的( B)。</p><p>A.可用性 B.可维护性 C.可扩展性 D.可移植性</p><p>100影响软件可维护性的主要因素不包括( C)。</p><p>A.可修改性 B.可测试性 C.可用性 D.可理解性</p><blockquote><p>商业用途禁止转载，个人复习使用免费</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;软件工程期末题库整理-仅供参考&quot;&gt;&lt;a href=&quot;#软件工程期末题库整理-仅供参考&quot; class=&quot;headerlink&quot; title=&quot;软件工程期末题库整理(仅供参考)&quot;&gt;&lt;/a&gt;软件工程期末题库整理(仅供参考)&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;欢迎来寻找bug,在评论区留言~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;点击前往微信小程序刷题：&quot;&gt;&lt;a href=&quot;#点击前往微信小程序刷题：&quot; class=&quot;headerlink&quot; title=&quot;点击前往微信小程序刷题：&quot;&gt;&lt;/a&gt;点击前往微信小程序刷题：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://tu.my/i/2022/06/06/629df0e066ed1.png&quot;&gt;我爱刷题-软件工程题库&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、判断题&quot;&gt;&lt;a href=&quot;#一、判断题&quot; class=&quot;headerlink&quot; title=&quot;一、判断题&quot;&gt;&lt;/a&gt;一、判断题&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;特别感谢某大佬和杨群大佬找出错误。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;软件就是程序，编写软件就是编写程序。 （X ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件危机的主要表现是软件需求增加，软件价格上升。 （ X ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;软件工程学科出现的主要原因是软件危机的出现。 （ √ ）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;瀑布模型的最大优点是将软件开发的各个阶段划分得十分清晰。 ( X )&lt;/p&gt;</summary>
    
    
    
    
    <category term="homework" scheme="https://qgdd.vercel.app/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>操作系统大作业</title>
    <link href="https://qgdd.vercel.app/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A/"/>
    <id>https://qgdd.vercel.app/2022/05/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E4%BD%9C%E4%B8%9A/</id>
    <published>2022-05-25T02:38:03.000Z</published>
    <updated>2022-05-28T01:03:03.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、计算题"><a href="#一、计算题" class="headerlink" title="一、计算题"></a>一、计算题</h1><p>本文转载自：<a href="https://blog.csdn.net/ChristensonLee/article/details/124169297?spm=1001.2014.3001.5502">KirinLee_01的博客-CSDN博客</a></p><blockquote><p>一个文件系统中有一个20MB大文件和一个20KB小文件,当分别采用连续、链接、i-node(10个直接地址，一个一级间接、一个二级间接和一个三级间接)分配方案时，每块大小为4KB,每块地址用4B表示，</p></blockquote><h2 id="问："><a href="#问：" class="headerlink" title="问："></a>问：</h2><blockquote><p>(1)各文件系统管理的最大的文件是多少?<br>(2)每种方案对大、小两文件各需要多少专用块来记录文件的物理地址(说明各块的用途)?<br>(3)如需要读大文件前面第5.5KB的信息和后面第（16M＋5.5KB）的信息，则每个方案各需要多少次盘I&#x2F;O操作?<br>(4)根据上述情况，分析比较三种文件分配方式的优劣。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d918bad25d.png" alt="在这里插入图片描述"></p><h2 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h2><h4 id="（1）各文件系统管理的最大的文件如下："><a href="#（1）各文件系统管理的最大的文件如下：" class="headerlink" title="（1）各文件系统管理的最大的文件如下："></a>（1）各文件系统管理的最大的文件如下：</h4><blockquote><p><strong>①连续分配：</strong></p><p>理论上是不受限制，可大到整个磁盘文件区。<br><strong>②链接分配：</strong></p><p>由于块的地址为4B，所以能表示的最多块数为2^32^&#x3D;4G，而每个盘块中存放文件大小为4KB。链接分配可管理的最大文件为：4G×4KB&#x3D;16368GB。</p><p><strong>③i-node分配</strong>：<br>由于盘块大小为4KB，每个地址用4B表示，一个盘块可存1K个索引表目。对于i-node(10个直接地址，一个一级间接、一个二级间接和一个三级间接)分配，即：10×4KB+ 4KB×1KB + 4KB×1KB×1KB + 4KB×1KB×1KB×1KB，因此可管理的最大文件为：4TB4GB4MB40KB。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d950936cd0.png" alt="在这里插入图片描述"></p><h4 id="（2）每种方案记录文件的物理地址所需的专用块数如下："><a href="#（2）每种方案记录文件的物理地址所需的专用块数如下：" class="headerlink" title="（2）每种方案记录文件的物理地址所需的专用块数如下："></a>（2）每种方案记录文件的物理地址所需的专用块数如下：</h4><blockquote><p><strong>①连续分配：</strong><br>对大小两个文件都只需在文件控制块FCB中设二项，一是首块物理块块号，另一是文件总块数，不需专用块来记录文件的物理地址。<br><strong>②链接分配：</strong><br>对大小两个文件都只需在文件控制块FCB中设二项，一是首块物理块块号，另一是末块物理块块号；同时在文件的每个物理块中设置存放下一个块号的指针,故不需专用块来记录文件的物理地址。<br><strong>③i-node分配：</strong><br>对20KB小文件只需在文件控制块FCB的i_addr[15]中使用前5个表目存放文件的物理块号，不需专用物理块。<br>对20MB大文件，FCB的i_addr[15]中使用前10个表目存放大文件前10块物理块块号（40K），用一级索引块1块保存大文件接着的1K块块号（4M），剩下还有不到16M，还要用二级索引存大文件以后的块号，二级索引使用第一级索引1块，第二级索引4块（因为4KB×1K×4&#x3D;16M）。<br>总共也需要6块专用物理块来存放文件物理地址。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d95164cfba.png" alt="在这里插入图片描述"></p><h4 id="（3）每个方案所需的盘I-x2F-O操作次数如下："><a href="#（3）每个方案所需的盘I-x2F-O操作次数如下：" class="headerlink" title="（3）每个方案所需的盘I&#x2F;O操作次数如下："></a>（3）每个方案所需的盘I&#x2F;O操作次数如下：</h4><blockquote><p><strong>①连续分配：</strong><br>为读大文件前面和后面信息都需先计算信息在文件中相对块数，前面信息相对逻辑块号为5.5K&#x2F;4K&#x3D;1（从0开始编号），再读一次得到所需信息，共2次盘I&#x2F;O。后面信息相对逻辑块号为（16M＋5.5K）&#x2F;4K&#x3D;4097。再计算物理块号＝文件首块号＋相对逻辑块号，最后一次盘I&#x2F;O操作读出该块信息，共4098次盘I&#x2F;O。<br><strong>②链接分配：</strong><br>为读大文件前面5.5KB的信息，只需先读一次文件头块得到信息所在块的块号，再读一次第1号逻辑块得到所需信息，共2次。<br>读大文件16MB＋5.5KB处的信息，逻辑块号为（16M＋5.5K）&#x2F;4092&#x3D;4107，要先把该信息所在块前面块顺序读出，共化4107次盘I&#x2F;O操作，才能得到信息所在块的块号，最后一次I&#x2F;O操作读出该块信息。所以总共需要4108次盘I&#x2F;O才能读取（16MB+5.5KB）处信息。<br><strong>③i-node分配：</strong><br>为读大文件前面5.5KB处信息，先根据它的相对逻辑块号，在内存文件控制块FCB的i_addr第二个表目中读取信息所在块块号，而1次盘I&#x2F;O操作即可读出该块信息。<br>为读大文件后在（16MB＋5.5KB）信息，先根据它的相对逻辑块号判断要读的信息是在二级索引管理范围内，先根据i_addr内容进行一次盘I&#x2F;O操作读出第一级索引块，再计算信息所在块的索引块号在第一级索引块的表目号为（4097-10-1024）&#x2F;1024＝2，根据第一级索引块第3个表目内容再进行一次盘I&#x2F;O操作，读出第二级索引块，就可以得到信息所在块块号，最后一次盘I&#x2F;O读出信息所在盘块，这样总共需要3次盘I&#x2F;O操作才能读出文件后面的信息。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d952a54332.png" alt="在这里插入图片描述"></p><h4 id="（4）由上可知三种文件分配方式的优劣如下："><a href="#（4）由上可知三种文件分配方式的优劣如下：" class="headerlink" title="（4）由上可知三种文件分配方式的优劣如下："></a>（4）由上可知三种文件分配方式的优劣如下：</h4><blockquote><p><strong>①连续分配：</strong><br>该方式要求每个文件在磁盘上占有一组连续的块。因此，物理上采用连续分配，存储空间利用率低，会产生难以利用的磁盘碎片。可以用紧凑来处理磁盘碎片，但是会需要耗费很大的时间代价。<br><strong>优点</strong>：实现简单，顺序存取速度快，适合顺序访问和直接访问（随机访问）。<br><strong>缺点：</strong>分配速度慢，不方便文件拓展，存储空间利用率低，外存碎片多（类似内存的可重定位可变分区分配）。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d954207ba2.png" alt="在这里插入图片描述"></p><blockquote><p><strong>②链接分配：</strong><br>该方式解决了连续分配的所有问题。采用链接分配，每个文件是磁盘块的链表；磁盘块可能会散布在磁盘的任何地方。目录包括文件第一块和最后一块的指针。<br><strong>优点：</strong>采用链接分配没有外部碎片，空闲空间列表的任何块可以用于满足请求。当创建文件时，并不需要说明文件的大小只，要有可用的空闲块，文件就可以继续增长。因此，无需合并磁盘空间。<br><strong>缺点：</strong>它只能有效用于顺序访问文件。要找到文件的第i个块，必须从文件的开始起，跟着指针，找到第i块。每个指针的访问都需要一个磁盘读，有时需要磁盘寻道。因此，链接分配不能有效支持文件的直接访问。另一个缺点是指针所需的空间。如果指针需要使用512 字节块的 4 字节，则 0.78% 的磁盘空间会用于指针，而不是其他信息。<br>因此，每个文件需要比原来稍多的空间，可靠性也降低，因为文件是通过散布在磁盘上的指针链接起来的，操作系统软件错误或磁盘硬件故障可能导致获得一个错误指针，这个错误可能会导致链接到空闲空间列表或链接到另一个文件。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d954c840f1.png" alt="在这里插入图片描述"></p><blockquote><p><strong>③i-node分配：</strong><br>链接分配解决了连续分配的外部碎片和大小声明的问题。然而，在没有 FAT时，链接分配不能支持髙效的直接访问，因为块指针与块一起分散在整个磁盘上，并且必须按序读取。那么索引分配（i-node）通过将所有指针放在一起，即索引块，解决了这个问题。每个文件都有自己的索引块，这是一个磁盘块地址的数组。索引块的第 i 个条目指向文件的第 i 个块。目录包含索引块的地址。当查找和读取第 i 个块时，采用第 i 个索引块条目的指针。<br><strong>优点：</strong>索引分配支持直接访问，并且没有外部碎片问题，因为磁盘的任何空闲块可以满足更多空间的请求。<br><strong>缺点：</strong>索引分配确实浪费空间。索引块指针的开销通常大于链接分配的指针开销。采用索引分配，即使只有一个或两个指针是非空的，也必须分配一个完整的索引块。然而，索引分配的性能取决于索引结构、文件大小以及所需块的位置，这显得比前两种方式不确定性高许多。</p></blockquote><p><img src="https://tu.my/i/2022/05/25/628d955cddb0f.png" alt="在这里插入图片描述"></p><p><img src="https://tu.my/i/2022/05/25/628d956a22e2a.png" alt="在这里插入图片描述"></p><blockquote><p>本文用于练习markdown语法,如有侵权,请联系删除。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;一、计算题&quot;&gt;&lt;a href=&quot;#一、计算题&quot; class=&quot;headerlink&quot; title=&quot;一、计算题&quot;&gt;&lt;/a&gt;一、计算题&lt;/h1&gt;&lt;p&gt;本文转载自：&lt;a href=&quot;https://blog.csdn.net/ChristensonLee/article/details/124169297?spm=1001.2014.3001.5502&quot;&gt;KirinLee_01的博客-CSDN博客&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个文件系统中有一个20MB大文件和一个20KB小文件,当分别采用连续、链接、i-node(10个直接地址，一个一级间接、一个二级间接和一个三级间接)分配方案时，每块大小为4KB,每块地址用4B表示，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问：&quot;&gt;&lt;a href=&quot;#问：&quot; class=&quot;headerlink&quot; title=&quot;问：&quot;&gt;&lt;/a&gt;问：&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;(1)各文件系统管理的最大的文件是多少?&lt;br&gt;(2)每种方案对大、小两文件各需要多少专用块来记录文件的物理地址(说明各块的用途)?&lt;br&gt;(3)如需要读大文件前面第5.5KB的信息和后面第（16M＋5.5KB）的信息，则每个方案各需要多少次盘I&amp;#x2F;O操作?&lt;br&gt;(4)根据上述情况，分析比较三种文件分配方式的优劣。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="homework" scheme="https://qgdd.vercel.app/tags/homework/"/>
    
  </entry>
  
  <entry>
    <title>图床测试</title>
    <link href="https://qgdd.vercel.app/2022/05/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/"/>
    <id>https://qgdd.vercel.app/2022/05/24/%E5%9B%BE%E5%BA%8A%E6%B5%8B%E8%AF%95/</id>
    <published>2022-05-24T09:22:30.000Z</published>
    <updated>2022-05-24T09:31:03.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如你所见"><a href="#如你所见" class="headerlink" title="如你所见"></a>如你所见</h2><p>我刚刚创建了一个免费图床,它叫做我的图床,虽然不知道是否稳定,但是感觉应该很快</p><p>试着加入一个贴图</p><p><img src="https://tu.my/i/2022/05/24/628c9fac53f6a.jpeg"></p><p>他好像上传成功了,你可以试着打开网页源代码,看看这副图片是不是来自其他网站的。</p><p>ps: 上面这个tags好麻烦,想想如何去掉它。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;如你所见&quot;&gt;&lt;a href=&quot;#如你所见&quot; class=&quot;headerlink&quot; title=&quot;如你所见&quot;&gt;&lt;/a&gt;如你所见&lt;/h2&gt;&lt;p&gt;我刚刚创建了一个免费图床,它叫做我的图床,虽然不知道是否稳定,但是感觉应该很快&lt;/p&gt;
&lt;p&gt;试着加入一个贴图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tu.my/i/2022/05/24/628c9fac53f6a.jpeg&quot;&gt;&lt;/p&gt;
&lt;p&gt;他好像上传成功了,你可以试着打开网页源代码,看看这副图片是不是来自其他网站的。&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>我的第一个博客</title>
    <link href="https://qgdd.vercel.app/2022/05/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    <id>https://qgdd.vercel.app/2022/05/24/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-05-24T06:39:43.000Z</published>
    <updated>2022-05-24T06:41:03.822Z</updated>
    
    <content type="html"><![CDATA[<h2 id="欢迎来到德莱联盟"><a href="#欢迎来到德莱联盟" class="headerlink" title="欢迎来到德莱联盟"></a>欢迎来到德莱联盟</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;欢迎来到德莱联盟&quot;&gt;&lt;a href=&quot;#欢迎来到德莱联盟&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到德莱联盟&quot;&gt;&lt;/a&gt;欢迎来到德莱联盟&lt;/h2&gt;</summary>
      
    
    
    
    
    <category term="test" scheme="https://qgdd.vercel.app/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://qgdd.vercel.app/2022/05/24/hello-world/"/>
    <id>https://qgdd.vercel.app/2022/05/24/hello-world/</id>
    <published>2022-05-24T03:33:50.449Z</published>
    <updated>2022-05-24T03:33:50.449Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&amp;quot;My New Post&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
</feed>
